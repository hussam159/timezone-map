{"ast":null,"code":"function createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction getCjsExportFromNamespace(n) {\n  return n && n['default'] || n;\n}\n\nvar fns = createCommonjsModule(function (module, exports) {\n  //git:blame @JuliasCaesar https://www.timeanddate.com/date/leapyear.html\n  exports.isLeapYear = function (year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }; // unsurprisingly-nasty `typeof date` call\n\n\n  exports.isDate = function (d) {\n    return Object.prototype.toString.call(d) === '[object Date]' && !isNaN(d.valueOf());\n  };\n\n  exports.isArray = function (input) {\n    return Object.prototype.toString.call(input) === '[object Array]';\n  };\n\n  exports.isObject = function (input) {\n    return Object.prototype.toString.call(input) === '[object Object]';\n  };\n\n  exports.zeroPad = function (str) {\n    var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var pad = '0';\n    str = str + '';\n    return str.length >= len ? str : new Array(len - str.length + 1).join(pad) + str;\n  };\n\n  exports.titleCase = function (str) {\n    if (!str) {\n      return '';\n    }\n\n    return str[0].toUpperCase() + str.substr(1);\n  };\n\n  exports.ordinal = function (i) {\n    var j = i % 10;\n    var k = i % 100;\n\n    if (j === 1 && k !== 11) {\n      return i + 'st';\n    }\n\n    if (j === 2 && k !== 12) {\n      return i + 'nd';\n    }\n\n    if (j === 3 && k !== 13) {\n      return i + 'rd';\n    }\n\n    return i + 'th';\n  }; //strip 'st' off '1st'..\n\n\n  exports.toCardinal = function (str) {\n    str = String(str);\n    str = str.replace(/([0-9])(st|nd|rd|th)$/i, '$1');\n    return parseInt(str, 10);\n  }; //used mostly for cleanup of unit names, like 'months'\n\n\n  exports.normalize = function () {\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    str = str.toLowerCase().trim();\n    str = str.replace(/ies$/, 'y'); //'centuries'\n\n    str = str.replace(/s$/, '');\n    str = str.replace(/-/g, '');\n\n    if (str === 'day') {\n      return 'date';\n    }\n\n    return str;\n  };\n\n  exports.getEpoch = function (tmp) {\n    //support epoch\n    if (typeof tmp === 'number') {\n      return tmp;\n    } //suport date objects\n\n\n    if (exports.isDate(tmp)) {\n      return tmp.getTime();\n    }\n\n    if (tmp.epoch) {\n      return tmp.epoch;\n    }\n\n    return null;\n  }; //make sure this input is a spacetime obj\n\n\n  exports.beADate = function (d, s) {\n    if (exports.isObject(d) === false) {\n      return s.clone().set(d);\n    }\n\n    return d;\n  };\n\n  exports.formatTimezone = function (offset) {\n    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var absOffset = Math.abs(offset);\n    var sign = offset > 0 ? '+' : '-';\n    return \"\".concat(sign).concat(exports.zeroPad(absOffset)).concat(delimiter, \"00\");\n  };\n});\nvar fns_1 = fns.isLeapYear;\nvar fns_2 = fns.isDate;\nvar fns_3 = fns.isArray;\nvar fns_4 = fns.isObject;\nvar fns_5 = fns.zeroPad;\nvar fns_6 = fns.titleCase;\nvar fns_7 = fns.ordinal;\nvar fns_8 = fns.toCardinal;\nvar fns_9 = fns.normalize;\nvar fns_10 = fns.getEpoch;\nvar fns_11 = fns.beADate;\nvar fns_12 = fns.formatTimezone;\nvar zeroPad = fns.zeroPad;\n\nvar toString = function toString(d) {\n  return zeroPad(d.getMonth() + 1) + '/' + zeroPad(d.getDate()) + ':' + zeroPad(d.getHours());\n}; // a timezone will begin with a specific offset in january\n// then some will switch to something else between november-march\n\n\nvar shouldChange = function shouldChange(epoch, start, end, defaultOffset) {\n  //note: this has a cray order-of-operations issue\n  //we can't get the date, without knowing the timezone, and vice-versa\n  //it's possible that we can miss a dst-change by a few hours.\n  var d = new Date(epoch); //(try to mediate this a little?)\n\n  var bias = d.getTimezoneOffset() || 0;\n  var shift = bias + defaultOffset * 60; //in minutes\n\n  shift = shift * 60 * 1000; //in ms\n\n  d = new Date(epoch + shift);\n  var current = toString(d); //eg. is it after ~november?\n\n  if (current >= start) {\n    //eg. is it before ~march~ too?\n    if (current < end) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar summerTime = shouldChange; // this method avoids having to do a full dst-calculation on every operation\n// it reproduces some things in ./index.js, but speeds up spacetime considerably\n\nvar quickOffset = function quickOffset(s) {\n  var zones = s.timezones;\n  var obj = zones[s.tz];\n\n  if (obj === undefined) {\n    console.warn(\"Warning: couldn't find timezone \" + s.tz);\n    return 0;\n  }\n\n  if (obj.dst === undefined) {\n    return obj.offset;\n  } //get our two possible offsets\n\n\n  var jul = obj.offset;\n  var dec = obj.offset + 1; // assume it's the same for now\n\n  if (obj.hem === 'n') {\n    dec = jul - 1;\n  }\n\n  var split = obj.dst.split('->');\n  var inSummer = summerTime(s.epoch, split[0], split[1], jul);\n\n  if (inSummer === true) {\n    return jul;\n  }\n\n  return dec;\n};\n\nvar quick = quickOffset;\nvar _build = {\n  \"9|s\": \"2/dili,2/jayapura\",\n  \"9|n\": \"2/chita,2/khandyga,2/pyongyang,2/seoul,2/tokyo,11/palau\",\n  \"9.5|s|04/07:03->10/06:02\": \"4/adelaide,4/broken_hill,4/south,4/yancowinna\",\n  \"9.5|s\": \"4/darwin,4/north\",\n  \"8|s\": \"12/casey,2/kuala_lumpur,2/makassar,2/singapore,4/perth,4/west\",\n  \"8|n|03/25:03->09/29:23\": \"2/ulan_bator\",\n  \"8|n\": \"2/brunei,2/choibalsan,2/chongqing,2/chungking,2/harbin,2/hong_kong,2/irkutsk,2/kuching,2/macao,2/macau,2/manila,2/shanghai,2/taipei,2/ujung_pandang,2/ulaanbaatar\",\n  \"8.75|s\": \"4/eucla\",\n  \"7|s\": \"12/davis,2/jakarta,9/christmas\",\n  \"7|n\": \"2/bangkok,2/barnaul,2/ho_chi_minh,2/hovd,2/krasnoyarsk,2/novokuznetsk,2/novosibirsk,2/phnom_penh,2/pontianak,2/saigon,2/tomsk,2/vientiane\",\n  \"6|s\": \"12/vostok\",\n  \"6|n\": \"2/almaty,2/bishkek,2/dacca,2/dhaka,2/kashgar,2/omsk,2/qyzylorda,2/thimbu,2/thimphu,2/urumqi,9/chagos\",\n  \"6.5|n\": \"2/rangoon,9/cocos\",\n  \"5|s\": \"12/mawson,9/kerguelen\",\n  \"5|n\": \"2/aqtau,2/aqtobe,2/ashgabat,2/ashkhabad,2/atyrau,2/baku,2/dushanbe,2/karachi,2/oral,2/samarkand,2/tashkent,2/yekaterinburg,9/maldives\",\n  \"5.75|n\": \"2/kathmandu,2/katmandu\",\n  \"5.5|n\": \"2/calcutta,2/colombo,2/kolkata\",\n  \"4|s\": \"9/reunion\",\n  \"4|n\": \"2/dubai,2/muscat,2/tbilisi,2/yerevan,8/astrakhan,8/samara,8/saratov,8/ulyanovsk,8/volgograd,2/volgograd,9/mahe,9/mauritius\",\n  \"4.5|n|03/22:00->09/21:24\": \"2/tehran\",\n  \"4.5|n\": \"2/kabul\",\n  \"3|s\": \"12/syowa,9/antananarivo\",\n  \"3|n|03/31:03->10/27:04\": \"2/nicosia,8/athens,8/bucharest,8/helsinki,8/kiev,8/mariehamn,8/nicosia,8/riga,8/sofia,8/tallinn,8/uzhgorod,8/vilnius,8/zaporozhye\",\n  \"3|n|03/31:02->10/27:03\": \"8/chisinau,8/tiraspol\",\n  \"3|n|03/31:00->10/26:24\": \"2/beirut\",\n  \"3|n|03/29:02->10/27:02\": \"2/jerusalem,2/tel_aviv\",\n  \"3|n|03/29:00->10/25:01\": \"2/amman\",\n  \"3|n|03/29:00->10/24:24\": \"2/damascus\",\n  \"3|n|03/23:01->10/26:01\": \"2/gaza,2/hebron\",\n  \"3|n\": \"0/addis_ababa,0/asmara,0/asmera,0/dar_es_salaam,0/djibouti,0/juba,0/kampala,0/mogadishu,0/nairobi,2/aden,2/baghdad,2/bahrain,2/istanbul,2/kuwait,2/qatar,2/riyadh,8/istanbul,8/kirov,8/minsk,8/moscow,8/simferopol,9/comoro,9/mayotte\",\n  \"2|s|03/31:02->10/27:02\": \"12/troll\",\n  \"2|s\": \"0/gaborone,0/harare,0/johannesburg,0/lubumbashi,0/lusaka,0/maputo,0/maseru,0/mbabane\",\n  \"2|n|03/31:02->10/27:03\": \"0/ceuta,arctic/longyearbyen,3/jan_mayen,8/amsterdam,8/andorra,8/belgrade,8/berlin,8/bratislava,8/brussels,8/budapest,8/busingen,8/copenhagen,8/gibraltar,8/ljubljana,8/luxembourg,8/madrid,8/malta,8/monaco,8/oslo,8/paris,8/podgorica,8/prague,8/rome,8/san_marino,8/sarajevo,8/skopje,8/stockholm,8/tirane,8/vaduz,8/vatican,8/vienna,8/warsaw,8/zagreb,8/zurich\",\n  \"2|n\": \"0/blantyre,0/bujumbura,0/cairo,0/khartoum,0/kigali,0/tripoli,8/kaliningrad\",\n  \"1|s|04/02:01->09/03:03\": \"0/windhoek\",\n  \"1|s\": \"0/kinshasa,0/luanda\",\n  \"1|n|05/05:03->06/09:02\": \"0/casablanca,0/el_aaiun\",\n  \"1|n|03/31:01->10/27:02\": \"3/canary,3/faeroe,3/faroe,3/madeira,8/belfast,8/dublin,8/guernsey,8/isle_of_man,8/jersey,8/lisbon,8/london\",\n  \"1|n\": \"0/algiers,0/bangui,0/brazzaville,0/douala,0/lagos,0/libreville,0/malabo,0/ndjamena,0/niamey,0/porto-novo,0/tunis\",\n  \"14|n\": \"11/kiritimati\",\n  \"13|s|04/07:04->09/29:03\": \"11/apia\",\n  \"13|s|01/15:02->11/05:03\": \"11/tongatapu\",\n  \"13|n\": \"11/enderbury,11/fakaofo\",\n  \"12|s|04/07:03->09/29:02\": \"12/mcmurdo,12/south_pole,11/auckland\",\n  \"12|s|01/13:03->11/03:02\": \"11/fiji\",\n  \"12|n\": \"2/anadyr,2/kamchatka,2/srednekolymsk,11/funafuti,11/kwajalein,11/majuro,11/nauru,11/tarawa,11/wake,11/wallis\",\n  \"12.75|s|04/07:03->04/07:02\": \"11/chatham\",\n  \"11|s\": \"12/macquarie,11/bougainville\",\n  \"11|n\": \"2/magadan,2/sakhalin,11/efate,11/guadalcanal,11/kosrae,11/noumea,11/pohnpei,11/ponape\",\n  \"11.5|n\": \"11/norfolk\",\n  \"10|s|04/07:03->10/06:02\": \"4/act,4/canberra,4/currie,4/hobart,4/melbourne,4/nsw,4/sydney,4/tasmania,4/victoria\",\n  \"10|s\": \"12/dumontdurville,4/brisbane,4/lindeman,4/queensland\",\n  \"10|n\": \"2/ust-nera,2/vladivostok,2/yakutsk,11/chuuk,11/guam,11/port_moresby,11/saipan,11/truk,11/yap\",\n  \"10.5|s|04/07:01->10/06:02\": \"4/lhi,4/lord_howe\",\n  \"0|n|03/31:00->10/27:01\": \"1/scoresbysund,3/azores\",\n  \"0|n\": \"0/abidjan,0/accra,0/bamako,0/banjul,0/bissau,0/conakry,0/dakar,0/freetown,0/lome,0/monrovia,0/nouakchott,0/ouagadougou,0/sao_tome,0/timbuktu,1/danmarkshavn,3/reykjavik,3/st_helena,13/gmt,13/gmt+0,13/gmt-0,13/gmt0,13/greenwich,13/utc,13/universal,13/zulu\",\n  \"-9|n|03/10:02->11/03:02\": \"1/adak,1/atka\",\n  \"-9|n\": \"11/gambier\",\n  \"-9.5|n\": \"11/marquesas\",\n  \"-8|n|03/10:02->11/03:02\": \"1/anchorage,1/juneau,1/metlakatla,1/nome,1/sitka,1/yakutat\",\n  \"-8|n\": \"11/pitcairn\",\n  \"-7|n|03/10:02->11/03:02\": \"1/dawson,1/ensenada,1/los_angeles,1/santa_isabel,1/tijuana,1/vancouver,1/whitehorse,6/pacific,6/yukon,10/bajanorte\",\n  \"-7|n\": \"1/creston,1/dawson_creek,1/hermosillo,1/phoenix\",\n  \"-6|s|04/06:22->09/07:22\": \"7/easterisland,11/easter\",\n  \"-6|n|04/07:02->10/27:02\": \"1/chihuahua,1/mazatlan,10/bajasur\",\n  \"-6|n|03/10:02->11/03:02\": \"1/boise,1/cambridge_bay,1/denver,1/edmonton,1/inuvik,1/ojinaga,1/shiprock,1/yellowknife,6/mountain\",\n  \"-6|n\": \"1/belize,1/costa_rica,1/el_salvador,1/guatemala,1/managua,1/regina,1/swift_current,1/tegucigalpa,6/east-saskatchewan,6/saskatchewan,11/galapagos\",\n  \"-5|s\": \"1/lima,1/rio_branco,5/acre\",\n  \"-5|n|04/07:02->10/27:02\": \"1/bahia_banderas,1/merida,1/mexico_city,1/monterrey,10/general\",\n  \"-5|n|03/12:03->11/05:01\": \"1/north_dakota\",\n  \"-5|n|03/10:02->11/03:02\": \"1/chicago,1/knox_in,1/matamoros,1/menominee,1/rainy_river,1/rankin_inlet,1/resolute,1/winnipeg,6/central\",\n  \"-5|n\": \"1/atikokan,1/bogota,1/cancun,1/cayman,1/coral_harbour,1/eirunepe,1/guayaquil,1/jamaica,1/panama,1/porto_acre\",\n  \"-4|s|05/13:23->08/13:01\": \"12/palmer\",\n  \"-4|s|04/06:24->09/08:00\": \"1/santiago,7/continental\",\n  \"-4|s|03/23:24->10/06:00\": \"1/asuncion\",\n  \"-4|s|02/16:24->11/03:00\": \"1/campo_grande,1/cuiaba\",\n  \"-4|s\": \"1/la_paz,1/manaus,5/west\",\n  \"-4|n|03/12:03->11/05:01\": \"1/indiana,1/kentucky\",\n  \"-4|n|03/10:02->11/03:02\": \"1/detroit,1/fort_wayne,1/grand_turk,1/indianapolis,1/iqaluit,1/louisville,1/montreal,1/nassau,1/new_york,1/nipigon,1/pangnirtung,1/port-au-prince,1/thunder_bay,1/toronto,6/eastern\",\n  \"-4|n|03/10:00->11/03:01\": \"1/havana\",\n  \"-4|n\": \"1/anguilla,1/antigua,1/aruba,1/barbados,1/blanc-sablon,1/boa_vista,1/caracas,1/curacao,1/dominica,1/grenada,1/guadeloupe,1/guyana,1/kralendijk,1/lower_princes,1/marigot,1/martinique,1/montserrat,1/port_of_spain,1/porto_velho,1/puerto_rico,1/santo_domingo,1/st_barthelemy,1/st_kitts,1/st_lucia,1/st_thomas,1/st_vincent,1/tortola,1/virgin\",\n  \"-3|s|02/16:24->11/03:00\": \"1/sao_paulo,5/east\",\n  \"-3|s\": \"1/argentina,1/buenos_aires,1/cordoba,1/fortaleza,1/montevideo,1/punta_arenas,12/rothera,3/stanley\",\n  \"-3|n|03/10:02->11/03:02\": \"1/glace_bay,1/goose_bay,1/halifax,1/moncton,1/thule,3/bermuda,6/atlantic\",\n  \"-3|n\": \"1/araguaina,1/bahia,1/belem,1/catamarca,1/cayenne,1/jujuy,1/maceio,1/mendoza,1/paramaribo,1/recife,1/rosario,1/santarem\",\n  \"-2|s\": \"5/denoronha\",\n  \"-2|n|03/30:22->10/26:23\": \"1/godthab\",\n  \"-2|n|03/10:02->11/03:02\": \"1/miquelon\",\n  \"-2|n\": \"1/noronha,3/south_georgia\",\n  \"-2.5|n|03/10:02->11/03:02\": \"1/st_johns,6/newfoundland\",\n  \"-1|n\": \"3/cape_verde\",\n  \"-11|n\": \"11/midway,11/niue,11/pago_pago,11/samoa\",\n  \"-10|n\": \"11/honolulu,11/johnston,11/rarotonga,11/tahiti\"\n};\n\nvar _build$1 = /*#__PURE__*/Object.freeze({\n  'default': _build\n}); //prefixes for iana names..\n\n\nvar _prefixes = ['africa', 'america', 'asia', 'atlantic', 'australia', 'brazil', 'canada', 'chile', 'europe', 'indian', 'mexico', 'pacific', 'antarctica', 'etc'];\nvar data = getCjsExportFromNamespace(_build$1);\nvar all = {};\nObject.keys(data).forEach(function (k) {\n  var split = k.split('|');\n  var obj = {\n    offset: Number(split[0]),\n    hem: split[1]\n  };\n\n  if (split[2]) {\n    obj.dst = split[2];\n  }\n\n  var names = data[k].split(',');\n  names.forEach(function (str) {\n    str = str.replace(/(^[0-9]+)\\//, function (before, num) {\n      num = Number(num);\n      return _prefixes[num] + '/';\n    });\n    all[str] = obj;\n  });\n});\nall['utc'] = {\n  offset: 0,\n  hem: 'n' //(sorry)\n\n}; //add etc/gmt+n\n\nfor (var i = -13; i <= 13; i += 0.5) {\n  var num = i;\n\n  if (num > 0) {\n    num = '+' + num;\n  }\n\n  var name = 'etc/gmt' + num;\n  all[name] = {\n    offset: i * -1,\n    //they're negative!\n    hem: 'n' //(sorry)\n\n  };\n  name = 'utc/gmt' + num; //this one too, why not.\n\n  all[name] = {\n    offset: i * -1,\n    hem: 'n'\n  };\n} // console.log(all)\n// console.log(Object.keys(all).length)\n\n\nvar unpack = all; // this is a very rough list of informal and abbreviated timezones\n// i am not an expert, or even half-knowledgeable in this subject.\n// please help.\n// partially from: https://en.wikipedia.org/wiki/list_of_time_zone_abbreviations\n//format:  'best/iana': [standard, daylight, alias...]\n\nvar informal = {\n  //north america\n  'america/halifax': ['ast', 'adt', 'atlantic'],\n  //or 'arabia standard time'\n  'america/new_york': ['est', 'edt', 'eastern'],\n  //or 'Ecuador Time'\n  'america/chicago': ['cst', 'cdt', 'central'],\n  'america/denver': ['mst', 'mdt', 'mountain'],\n  'america/los_angeles': ['pst', 'pdt', 'pacific'],\n  'america/anchorage': ['ahst', 'ahdt', 'akst', 'akdt', 'alaska'],\n  //Alaska Standard Time\n  'america/st_johns': ['nst', 'ndt', 'nt', 'newfoundland', 'nddt'],\n  //south america\n  'america/caracas': ['vet', null, 'venezuela'],\n  'america/bogota': ['cot', null, 'colombia'],\n  'america/cayenne': ['gft', null, 'french guiana'],\n  'america/paramaribo': ['srt', null, 'suriname'],\n  'america/guyana': ['gyt'],\n  'america/buenos_aires': ['art', null, 'argentina'],\n  'america/la_paz': ['bot', null, 'bolivia'],\n  'america/asuncion': ['pyt', 'pyst', 'paraguay'],\n  'america/santiago': ['clt', 'clst', 'chile'],\n  'america/lima': ['pet', null, 'peru'],\n  'america/montevideo': ['uyt', null, 'uruguay'],\n  'atlantic/stanley': ['fkst', null, 'falkland island'],\n  //brazil\n  'america/manaus': ['amt'],\n  'america/sao_paulo': ['brt', 'brst'],\n  'brazil/acre': ['act'],\n  // amst: -3, //amazon summer time (brazil)\n  // fnt: -2, //fernando de noronha time\n  // pmdt: -2, //saint pierre and miquelon daylight time\n  // pmst: -3, //saint pierre and miquelon standard time\n  // rott: -3, //rothera research station time\n  // awt: 'america/blanc-sablon',\n  // addt: 'america/pangnirtung',\n  // apt: 'america/blanc-sablon',\n  // cddt: 'america/rankin_inlet',\n  // cwt: 'america/mexico_city',\n  // cpt: 'america/atikokan',\n  // eddt: 'america/iqaluit',\n  // ept: 'america/detroit',\n  // ewt: 'america/detroit',\n  // ect: 'america/anguilla', //eastern caribbean time (does not recognise dst)\n  // 'eastern caribbean': 'america/anguilla',\n  // ffmt: 'america/martinique',\n  // kmt: 'america/grand_turk',\n  // mddt: 'america/cambridge_bay',\n  // mpt: 'america/boise',\n  // mwt: 'america/phoenix',\n  // nwt: 'america/adak',\n  // // npt: 'america/goose_bay',\n  // pddt: 'america/inuvik',\n  // ppmt: 'america/port-au-prince',\n  // ppt: 'america/dawson_creek',\n  // pwt: 'america/dawson_creek',\n  // qmt: 'america/guayaquil',\n  // sdmt: 'america/santo_domingo',\n  // sjmt: 'america/costa_rica',\n  // ydt: 'america/dawson', //yukon\n  // ypt: 'america/dawson',\n  // yddt: 'america/dawson',\n  // ywt: 'america/dawson',\n  // yst: 'america/whitehorse',\n  //europe\n  'europe/london': ['gmt', 'bst', 'british'],\n  //britain is different\n  'etc/gmt': ['gmt', null, 'greenwich'],\n  'europe/lisbon': ['wet', 'west', 'west europe'],\n  //western europe\n  'europe/berlin': ['cet', 'cest', 'central europe', 'middle european', 'met', 'mest'],\n  //central europe\n  'europe/riga': ['eet', 'eest', 'east europe', 'kalt'],\n  //eastern europe\n  // -- these are old european ones, before the EU, i think:\n  // 'europe/minsk': ['feet', 'feest', 'eastern europe'], //further eastern europe (discontinued)\n  // ace: 'europe/dublin',\n  // amt: 'europe/amsterdam',\n  // bdst: 'europe/gibraltar',\n  // bmt: 'europe/brussels',\n  // bst: 'europe/gibraltar', //british summer time\n  // 'british summer': 1,\n  // dmt: 'europe/dublin',\n  // dft: 1, //aix-specific equivalent of central european time\n  // cmt: 'europe/copenhagen',\n  // // ist: 'europe/dublin',\n  // imt: 'europe/sofia',\n  // lst: 'europe/riga',\n  // pmt: 'europe/prague',\n  // rmt: 'europe/rome',\n  // set: 'europe/stockholm',\n  // wemt: 'europe/madrid',\n  // tse: 'europe/dublin',\n  // utc: 'etc/utc', //coordinated universal time\n  // 'coordinated universal': 'etc/utc',\n  //russia\n  'europe/moscow': ['msk', null, 'fet', 'mdst', 'msd'],\n  //'further eastern europe'\n  'europe/samara': ['samt'],\n  'asia/yekaterinburg': ['yekt'],\n  'asia/omsk': ['omst'],\n  'asia/krasnoyarsk': ['krat'],\n  'asia/novosibirsk': ['novt'],\n  'asia/irkutsk': ['irkt'],\n  'asia/yakutsk': ['yakt'],\n  'asia/vladivostok': ['vlat'],\n  'asia/magadan': ['magt'],\n  'asia/sakhalin': ['sakt'],\n  'asia/srednekolymsk': ['sret'],\n  'asia/anadyr': ['anat'],\n  'asia/kamchatka': ['pett'],\n  //near-russia\n  'asia/tashkent': ['uzt', 'uzbekistan'],\n  //uzbekistan time\n  'asia/bishkek': ['kgt', 'kyrgyzstan'],\n  //kyrgyzstan time\n  'antarctica/vostok': ['vost'],\n  'asia/hovd': ['hovt'],\n  'asia/ashgabat': ['tmt', null, 'turkmenistan'],\n  // wmt: 'europe/warsaw',\n  // 'europe/volgograd':['volt']\n  //africa\n  'africa/lagos': ['wat', 'wast', 'west africa'],\n  //west african\n  'africa/khartoum': ['cat', null, 'central africa'],\n  'africa/nairobi': ['eat', null, 'east africa'],\n  'atlantic/cape_verde': ['cvt'],\n  'indian/mauritius': ['mut'],\n  'indian/reunion': ['ret'],\n  'africa/johannesburg': ['sast', null, 'south africa'],\n  //atlantic\n  'atlantic/azores': ['azot', 'azost', 'hmt'],\n  'america/godthab': ['wgt', 'wgst', 'west greenland'],\n  'america/scoresbysund': ['egt', 'egst', 'east greenland'],\n  //middle-east\n  'europe/istanbul': ['trt', null, 'turkey'],\n  'asia/tbilisi': ['get', null, 'georgia'],\n  // 'asia/yerevan': ['amt', null, 'armenia'], //(sorry!)\n  'asia/baku': ['azt', null, 'azerbaijan'],\n  'asia/jerusalem': [null, 'idt', 'israel', 'jmt', 'iddt'],\n  //using ist for india\n  'asia/tehran': ['irst', 'irdt', 'iran'],\n  'asia/karachi': ['pkt', null, 'pakistan'],\n  'asia/kabul': ['aft', null, 'afghanistan'],\n  'asia/dushanbe': ['tjt', null, 'tajikistan'],\n  'asia/almaty': ['almt', null, 'alma ata'],\n  'asia/dubai': ['gst', null, 'gulf'],\n  //india\n  'asia/kolkata': ['ist', null, 'india', 'slst'],\n  // 'asia/dhaka': ['bst', null, 'bangladesh'], //(sorry)\n  'asia/thimbu': ['btt', null, 'bhutan'],\n  'indian/maldives': ['mvt'],\n  'asia/kathmandu': ['npt', null, 'nepal'],\n  'indian/cocos': ['cct', null, 'cocos island'],\n  'indian/chagos': ['iot', null, 'indian chagos'],\n  'indian/kerguelen': ['tft', null, 'french southern and antarctic'],\n  // biot: 6, //british indian ocean time\n  // iot: 3, //indian ocean time\n  //asia\n  'asia/shanghai': ['ct', null, 'china', 'hkt'],\n  'asia/ulaanbaatar': ['ulat'],\n  'asia/seoul': ['kst', null, 'korea'],\n  'asia/tokyo': ['jst', null, 'japan'],\n  'asia/phnom_penh': ['ict', null, 'indochina'],\n  'asia/manila': ['pht', null, 'philippines'],\n  'asia/singapore': ['sgt'],\n  // mmt: 'asia/colombo',\n  //australia\n  'australia/brisbane': ['aest', 'aedt', 'australian east'],\n  //australian eastern standard time\n  'australia/adelaide': ['acst', 'acdt', 'australian central'],\n  //australian central daylight savings time\n  'australia/eucla': ['acwst', null, 'cwst', 'australian central western'],\n  //australian central western standard time (unofficial)\n  'australia/perth': ['awst', 'awdt', 'australian west'],\n  //australian western standard time\n  'pacific/auckland': ['nzst', 'nzdt', 'nzmt'],\n  'australia/lord_howe': ['lhst', 'lhdt'],\n  //pacific\n  'pacific/guam': ['chst'],\n  'pacific/chatham': ['chast', 'chadt'],\n  'pacific/honolulu': ['hst'],\n  'asia/brunei': ['bnt', null, 'bdt'],\n  'pacific/midway': ['sst', null, 'samoa', 'sdt'],\n  'pacific/niue': ['nut'],\n  'pacific/fakaofo': ['tkt'],\n  'pacific/rarotonga': ['ckt', null, 'cook islands'],\n  'chile/easterisland': ['east', 'easst', 'easter island', 'emt'],\n  'asia/jayapura': ['wit', null, 'east indonesia'],\n  'asia/jakarta': ['wib', null, 'west indonesia'],\n  'asia/makassar': ['wita', null, 'central indonesia'],\n  'pacific/galapagos': ['galt'],\n  'pacific/fiji': ['fjt', 'fjst'],\n  'asia/dili': ['tlt', null, 'east timor'],\n  'indian/christmas': ['cxt'] // sbt: 11, //solomon islands time\n  // mht: 12, //marshall islands time\n  // bit: -12, //baker island time\n  // cist: -8, //clipperton island standard time\n  // chut: 10, //chuuk time\n  // ddut: 10, //dumont durville time\n  // gst: 'pacific/guam',\n  // gamt: -9, //gambier islands time\n  // git: -9, //gambier island time\n  // gilt: 12, //gilbert island time\n  // idlw: -12, //international day line west time zone\n  // 'international day line west': -12,\n  // kost: 11, //kosrae time\n  // lint: 14, //line islands time\n  // magt: 12, //magadan time\n  // mist: 11, //macquarie island station time\n  // nct: 11, //new caledonia time\n  // nft: 11, //norfolk island time\n  // phot: 13, //phoenix island time\n  // pont: 11, //pohnpei standard time\n  // pett: 12, //kamchatka time\n  // mart: -9.5, //marquesas islands time\n  // mit: -9.5, //marquesas islands time\n  // myt: 8, //malaysia time\n  // nut: -11, //niue time\n  // pht: 8, //philippine time\n  // pgt: 10, //papua new guinea time\n  // pmmt: 'pacific/bougainville',\n  // // smt: 'asia/singapore',\n  // sakt: 11, //sakhalin island time\n  // sret: 11, //srednekolymsk time\n  // sst: 'pacific/pago_pago',\n  // taht: -10, //tahiti time\n  // tvt: 12, //tuvalu time\n  // tkt: 13, //tokelau time\n  // tot: 13, //tonga time\n  // vut: 11, //vanuatu time\n  // wakt: 12, //wake island time\n  //i forget (sorry!)\n  // haec: 2, //heure avancée deurope centrale french-language name for cest\n  // syot: 3, //showa station time\n  // yekt: 5, //yekaterinburg time\n  // sct: 4, //seychelles time\n  // orat: 5, //oral time\n  // mawt: 5, //mawson station time\n  // hovt: 7, //khovd standard time\n  // hovst: 8, //khovd summer time\n  // davt: 7, //davis time\n  // chost: 9, //choibalsan summer time\n  // chot: 8, //choibalsan standard time\n  // wst: 8, //western standard time\n\n}; //use each abbreviation as a key\n\nvar lookup = Object.keys(informal).reduce(function (h, k) {\n  var arr = informal[k];\n\n  for (var _i = 0; _i < 5; _i += 1) {\n    if (arr[_i]) {\n      h[arr[_i]] = k;\n    }\n  }\n\n  return h;\n}, {});\nvar informal_1 = {\n  informal: informal,\n  lookup: lookup\n}; //find the implicit iana code for this machine.\n//safely query the Intl object\n//based on - https://bitbucket.org/pellepim/jstimezonedetect/src\n\nvar fallbackTZ = 'utc'; //\n//this Intl object is not supported often, yet\n\nvar safeIntl = function safeIntl() {\n  if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {\n    return null;\n  }\n\n  var format = Intl.DateTimeFormat();\n\n  if (typeof format === 'undefined' || typeof format.resolvedOptions === 'undefined') {\n    return null;\n  }\n\n  var timezone = format.resolvedOptions().timeZone;\n\n  if (!timezone) {\n    return null;\n  }\n\n  return timezone.toLowerCase();\n};\n\nvar guessTz = function guessTz() {\n  var timezone = safeIntl();\n\n  if (timezone === null) {\n    return fallbackTZ;\n  }\n\n  return timezone;\n}; //do it once per computer\n\n\nvar guessTz_1 = guessTz;\nvar informal$1 = informal_1.lookup;\nvar local = guessTz_1();\nvar isOffset = /(\\-?[0-9]+)h(rs)?/; //add all the city names by themselves\n\nvar cities = Object.keys(unpack).reduce(function (h, k) {\n  var city = k.split('/')[1] || '';\n  city = city.replace(/_/g, ' ');\n  h[city] = k;\n  return h;\n}, {}); //try to match these against iana form\n\nvar normalize = function normalize(tz) {\n  tz = tz.replace(/ time/g, '');\n  tz = tz.replace(/ (standard|daylight|summer)/g, '');\n  tz = tz.replace(/\\b(east|west|north|south)ern/g, '$1');\n  tz = tz.replace(/\\b(africa|america|australia)n/g, '$1');\n  tz = tz.replace(/\\beuropean/g, 'europe');\n  tz = tz.replace(/\\islands/g, 'island');\n  return tz;\n}; // try our best to reconcile the timzone to this given string\n\n\nvar lookupTz = function lookupTz(str, zones) {\n  if (!str) {\n    return local;\n  }\n\n  var tz = str.trim();\n  var split = str.split('/'); //support long timezones like 'America/Argentina/Rio_Gallegos'\n\n  if (split.length > 2 && zones.hasOwnProperty(tz) === false) {\n    tz = split[0] + '/' + split[1];\n  }\n\n  tz = tz.toLowerCase();\n\n  if (zones.hasOwnProperty(tz) === true) {\n    return tz;\n  } //lookup more loosely..\n\n\n  tz = normalize(tz);\n\n  if (zones.hasOwnProperty(tz) === true) {\n    return tz;\n  } //try abbrevations and things\n\n\n  if (informal$1.hasOwnProperty(tz) === true) {\n    return informal$1[tz];\n  } //try city-names\n\n\n  if (cities.hasOwnProperty(tz) === true) {\n    return cities[tz];\n  } // //try to parse '-5h'\n\n\n  var m = tz.match(isOffset);\n\n  if (m !== null) {\n    var _num = Number(m[1]);\n\n    _num = _num * -1; //it's opposite!\n\n    _num = (_num > 0 ? '+' : '') + _num;\n    var gmt = 'etc/gmt' + _num;\n\n    if (zones.hasOwnProperty(gmt)) {\n      return gmt;\n    }\n  }\n\n  console.warn(\"Cannot find timezone named: '\" + str + \"'\");\n  return local;\n};\n\nvar find = lookupTz;\nvar o = {\n  millisecond: 1\n};\no.second = 1000;\no.minute = 60000;\no.hour = 3.6e6; // dst is supported post-hoc\n\no.day = 8.64e7; //\n\no.date = o.day;\no.month = 8.64e7 * 29.5; //(average)\n\no.week = 6.048e8;\no.year = 3.154e10; // leap-years are supported post-hoc\n//add plurals\n\nObject.keys(o).forEach(function (k) {\n  o[k + 's'] = o[k];\n});\nvar milliseconds = o; //basically, step-forward/backward until js Date object says we're there.\n\nvar walk = function walk(s, n, fn, unit, previous) {\n  var current = s.d[fn]();\n\n  if (current === n) {\n    return; //already there\n  }\n\n  var startUnit = previous === null ? null : s.d[previous]();\n  var original = s.epoch; //try to get it as close as we can\n\n  var diff = n - current;\n  s.epoch += milliseconds[unit] * diff; //DST edge-case: if we are going many days, be a little conservative\n\n  if (unit === 'day' && Math.abs(diff) > 28) {\n    //but don't push it over a month\n    if (n < 28) {\n      s.epoch += milliseconds.hour;\n    }\n  } //repair it if we've gone too far or something\n  //(go by half-steps, just in case)\n\n\n  var halfStep = milliseconds[unit] / 2;\n\n  while (s.d[fn]() < n) {\n    s.epoch += halfStep;\n  }\n\n  while (s.d[fn]() > n) {\n    s.epoch -= halfStep;\n  } //oops, did we change previous unit? revert it.\n\n\n  if (previous !== null && startUnit !== s.d[previous]()) {\n    // console.warn('spacetime warning: missed setting ' + unit)\n    s.epoch = original; // i mean, but make it close...\n\n    s.epoch += milliseconds[unit] * diff * 0.97; // i guess?\n  }\n}; //find the desired date by a increment/check while loop\n\n\nvar units = {\n  year: {\n    valid: function valid(n) {\n      return n > -4000 && n < 4000;\n    },\n    walkTo: function walkTo(s, n) {\n      return walk(s, n, 'getFullYear', 'year', null);\n    }\n  },\n  month: {\n    valid: function valid(n) {\n      return n >= 0 && n <= 11;\n    },\n    walkTo: function walkTo(s, n) {\n      var d = s.d;\n      var current = d.getMonth();\n      var original = s.epoch;\n      var startUnit = d.getYear();\n\n      if (current === n) {\n        return;\n      } //try to get it as close as we can..\n\n\n      var diff = n - current;\n      s.epoch += milliseconds.day * (diff * 28); //special case\n      //oops, did we change the year? revert it.\n\n      if (startUnit !== s.d.getYear()) {\n        s.epoch = original;\n      } //incriment by day\n\n\n      while (s.d.getMonth() < n) {\n        s.epoch += milliseconds.day;\n      }\n\n      while (s.d.getMonth() > n) {\n        s.epoch -= milliseconds.day;\n      }\n    }\n  },\n  date: {\n    valid: function valid(n) {\n      return n > 0 && n <= 31;\n    },\n    walkTo: function walkTo(s, n) {\n      return walk(s, n, 'getDate', 'day', 'getMonth');\n    }\n  },\n  hour: {\n    valid: function valid(n) {\n      return n >= 0 && n < 24;\n    },\n    walkTo: function walkTo(s, n) {\n      return walk(s, n, 'getHours', 'hour', 'getDate');\n    }\n  },\n  minute: {\n    valid: function valid(n) {\n      return n >= 0 && n < 60;\n    },\n    walkTo: function walkTo(s, n) {\n      return walk(s, n, 'getMinutes', 'minute', 'getHours');\n    }\n  },\n  second: {\n    valid: function valid(n) {\n      return n >= 0 && n < 60;\n    },\n    walkTo: function walkTo(s, n) {\n      //do this one directly\n      s.epoch = s.seconds(n).epoch;\n    }\n  },\n  millisecond: {\n    valid: function valid(n) {\n      return n >= 0 && n < 1000;\n    },\n    walkTo: function walkTo(s, n) {\n      //do this one directly\n      s.epoch = s.milliseconds(n).epoch;\n    }\n  }\n};\n\nvar walkTo = function walkTo(s, wants) {\n  var keys = Object.keys(units);\n  var old = s.clone();\n\n  for (var _i2 = 0; _i2 < keys.length; _i2++) {\n    var k = keys[_i2];\n    var n = wants[k];\n\n    if (n === undefined) {\n      n = old[k]();\n    }\n\n    if (typeof n === 'string') {\n      n = parseInt(n, 10);\n    } //make-sure it's valid\n\n\n    if (!units[k].valid(n)) {\n      s.epoch = null;\n\n      if (s.silent === false) {\n        console.warn('invalid ' + k + ': ' + n);\n      }\n\n      return;\n    } // console.log(k, n)\n\n\n    units[k].walkTo(s, n);\n  }\n\n  return;\n};\n\nvar walk_1 = walkTo;\nvar shortMonths = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sept', 'oct', 'nov', 'dec'];\nvar longMonths = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\n\nfunction buildMapping() {\n  var obj = {\n    sep: 8 //support this format\n\n  };\n\n  for (var _i3 = 0; _i3 < shortMonths.length; _i3++) {\n    obj[shortMonths[_i3]] = _i3;\n  }\n\n  for (var _i4 = 0; _i4 < longMonths.length; _i4++) {\n    obj[longMonths[_i4]] = _i4;\n  }\n\n  return obj;\n}\n\nvar months = {\n  short: function short() {\n    return shortMonths;\n  },\n  long: function long() {\n    return longMonths;\n  },\n  mapping: function mapping() {\n    return buildMapping();\n  },\n  set: function set(i18n) {\n    shortMonths = i18n.short || shortMonths;\n    longMonths = i18n.long || longMonths;\n  }\n}; //pull-apart ISO offsets, like \"+0100\"\n\nvar parseOffset = function parseOffset(s, offset) {\n  if (!offset) {\n    return s;\n  } //this is a fancy-move\n\n\n  if (offset === 'Z') {\n    offset = '+0000';\n  } // according to ISO8601, tz could be hh:mm, hhmm or hh\n  // so need few more steps before the calculation.\n\n\n  var num = 0; // for (+-)hh:mm\n\n  if (/^[\\+-]?[0-9]{2}:[0-9]{2}$/.test(offset)) {\n    //support \"+01:00\"\n    if (/:00/.test(offset) === true) {\n      offset = offset.replace(/:00/, '');\n    } //support \"+01:30\"\n\n\n    if (/:30/.test(offset) === true) {\n      offset = offset.replace(/:30/, '.5');\n    }\n  } // for (+-)hhmm\n\n\n  if (/^[\\+-]?[0-9]{4}$/.test(offset)) {\n    offset = offset.replace(/30$/, '.5');\n  }\n\n  num = parseFloat(offset); //divide by 100 or 10 - , \"+0100\", \"+01\"\n\n  if (Math.abs(num) > 100) {\n    num = num / 100;\n  } //okay, try to match it to a utc timezone\n  //remember - this is opposite! a -5 offset maps to Etc/GMT+5  ¯\\_(:/)_/¯\n  //https://askubuntu.com/questions/519550/why-is-the-8-timezone-called-gmt-8-in-the-filesystem\n\n\n  num *= -1;\n\n  if (num >= 0) {\n    num = '+' + num;\n  }\n\n  var tz = 'etc/gmt' + num;\n  var zones = s.timezones;\n\n  if (zones[tz]) {\n    // log a warning if we're over-writing a given timezone?\n    // console.log('changing timezone to: ' + tz)\n    s.tz = tz;\n  }\n\n  return s;\n};\n\nvar parseOffset_1 = parseOffset;\n\nvar parseTime = function parseTime(s) {\n  var str = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  str = str.replace(/^\\s+/, '').toLowerCase(); //trim\n  //formal time formats - 04:30.23\n\n  var arr = str.match(/([0-9]{1,2}):([0-9]{1,2}):?([0-9]{1,2})?[:\\.]?([0-9]{1,4})?/);\n\n  if (arr !== null) {\n    //validate it a little\n    var h = Number(arr[1]);\n\n    if (h < 0 || h > 24) {\n      return s.startOf('day');\n    }\n\n    var m = Number(arr[2]); //don't accept '5:3pm'\n\n    if (arr[2].length < 2 || m < 0 || m > 59) {\n      return s.startOf('day');\n    }\n\n    s = s.hour(h);\n    s = s.minute(m);\n    s = s.seconds(arr[3] || 0);\n    s = s.millisecond(arr[4] || 0); //parse-out am/pm\n\n    var ampm = str.match(/[\\b0-9](am|pm)\\b/);\n\n    if (ampm !== null && ampm[1]) {\n      s = s.ampm(ampm[1]);\n    }\n\n    return s;\n  } //try an informal form - 5pm (no minutes)\n\n\n  arr = str.match(/([0-9]+) ?(am|pm)/);\n\n  if (arr !== null && arr[1]) {\n    var _h = Number(arr[1]); //validate it a little..\n\n\n    if (_h > 12 || _h < 1) {\n      return s.startOf('day');\n    }\n\n    s = s.hour(arr[1] || 0);\n    s = s.ampm(arr[2]);\n    s = s.startOf('hour');\n    return s;\n  } //no time info found, use start-of-day\n\n\n  s = s.startOf('day');\n  return s;\n};\n\nvar parseTime_1 = parseTime;\nvar monthLengths = [31, // January - 31 days\n28, // February - 28 days in a common year and 29 days in leap years\n31, // March - 31 days\n30, // April - 30 days\n31, // May - 31 days\n30, // June - 30 days\n31, // July - 31 days\n31, // August - 31 days\n30, // September - 30 days\n31, // October - 31 days\n30, // November - 30 days\n31 // December - 31 days\n];\nvar monthLengths_1 = monthLengths;\nvar isLeapYear = fns.isLeapYear; //given a month, return whether day number exists in it\n\nvar hasDate = function hasDate(obj) {\n  //invalid values\n  if (monthLengths_1.hasOwnProperty(obj.month) !== true) {\n    return false;\n  } //support leap-year in february\n\n\n  if (obj.month === 1) {\n    if (isLeapYear(obj.year) && obj.date <= 29) {\n      return true;\n    } else {\n      return obj.date <= 28;\n    }\n  } //is this date too-big for this month?\n\n\n  var max = monthLengths_1[obj.month] || 0;\n\n  if (obj.date <= max) {\n    return true;\n  }\n\n  return false;\n};\n\nvar hasDate_1 = hasDate;\nvar months$1 = months.mapping();\n\nvar parseYear = function parseYear() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  //support '18 -> 2018\n  // str = str.replace(/^'([0-9]{2})/, '20$1')\n  // str = str.replace('([0-9]+) ?b\\.?c\\.?$', '-$1')\n  var year = parseInt(str.trim(), 10);\n  year = year || new Date().getFullYear();\n  return year;\n};\n\nvar strFmt = [//iso-this 1998-05-30T22:00:00:000Z, iso-that 2017-04-03T08:00:00-0700\n{\n  reg: /^(\\-?0?0?[0-9]{3,4})-([0-9]{1,2})-([0-9]{1,2})[T| ]([0-9.:]+)(Z|[0-9\\-\\+:]+)?$/,\n  parse: function parse(s, arr, givenTz, options) {\n    var month = parseInt(arr[2], 10) - 1;\n    var obj = {\n      year: arr[1],\n      month: month,\n      date: arr[3]\n    };\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    parseOffset_1(s, arr[5]);\n    walk_1(s, obj);\n    s = parseTime_1(s, arr[4]);\n    return s;\n  }\n}, //iso \"2015-03-25\" or \"2015/03/25\" //0-based-months!\n{\n  reg: /^([0-9]{4})[\\-\\/]([0-9]{1,2})[\\-\\/]([0-9]{1,2})$/,\n  parse: function parse(s, arr) {\n    var obj = {\n      year: arr[1],\n      month: parseInt(arr[2], 10) - 1,\n      date: parseInt(arr[3], 10)\n    };\n\n    if (obj.month >= 12) {\n      //support yyyy/dd/mm (weird, but ok)\n      obj.date = parseInt(arr[2], 10);\n      obj.month = parseInt(arr[3], 10) - 1;\n    }\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walk_1(s, obj);\n    s = parseTime_1(s);\n    return s;\n  }\n}, //short - uk \"03/25/2015\"  //0-based-months!\n{\n  reg: /^([0-9]{1,2})[\\-\\/]([0-9]{1,2})[\\-\\/]?([0-9]{4})?$/,\n  parse: function parse(s, arr) {\n    var month = parseInt(arr[1], 10) - 1;\n    var date = parseInt(arr[2], 10);\n\n    if (month >= 12) {\n      //support yyyy/dd/mm (weird, but ok)\n      month = parseInt(arr[2], 10) - 1;\n      date = parseInt(arr[1], 10);\n    }\n\n    var year = arr[3] || new Date().getFullYear();\n    var obj = {\n      year: year,\n      month: month,\n      date: date\n    };\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walk_1(s, obj);\n    s = parseTime_1(s);\n    return s;\n  }\n}, //Long \"Mar 25 2015\"\n//February 22, 2017 15:30:00\n{\n  reg: /^([a-z]+) ([0-9]{1,2}(?:st|nd|rd|th)?),?( [0-9]{4})?( ([0-9:]+( ?am| ?pm)?))?$/i,\n  parse: function parse(s, arr) {\n    var month = months$1[arr[1].toLowerCase()];\n    var year = parseYear(arr[3]);\n    var obj = {\n      year: year,\n      month: month,\n      date: fns.toCardinal(arr[2] || '')\n    };\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walk_1(s, obj);\n    s = parseTime_1(s, arr[4]);\n    return s;\n  }\n}, //February 2017 (implied date)\n{\n  reg: /^([a-z]+) ([0-9]{4})$/i,\n  parse: function parse(s, arr) {\n    var month = months$1[arr[1].toLowerCase()];\n    var year = parseYear(arr[2]);\n    var obj = {\n      year: year,\n      month: month,\n      date: 1\n    };\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walk_1(s, obj);\n    s = parseTime_1(s, arr[4]);\n    return s;\n  }\n}, //Long \"25 Mar 2015\"\n{\n  reg: /^([0-9]{1,2}(?:st|nd|rd|th)?) ([a-z]+),?( [0-9]{4})?$/i,\n  parse: function parse(s, arr) {\n    var month = months$1[arr[2].toLowerCase()];\n    var year = parseYear(arr[3]);\n    var obj = {\n      year: year,\n      month: month,\n      date: fns.toCardinal(arr[1])\n    };\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walk_1(s, obj);\n    s = parseTime_1(s);\n    return s;\n  }\n}, {\n  // '1992'\n  reg: /^[0-9]{4}$/i,\n  parse: function parse(s, arr) {\n    var year = parseYear(arr[0]);\n    var d = new Date();\n    var obj = {\n      year: year,\n      month: d.getMonth(),\n      date: d.getDate()\n    };\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walk_1(s, obj);\n    s = parseTime_1(s);\n    return s;\n  }\n}, {\n  // '200bc'\n  reg: /^[0-9,]+ ?b\\.?c\\.?$/i,\n  parse: function parse(s, arr) {\n    var str = arr[0] || ''; //make negative-year\n\n    str = str.replace(/^([0-9,]+) ?b\\.?c\\.?$/i, '-$1'); //remove commas\n\n    str = str.replace(/,/g, '');\n    var year = parseInt(str.trim(), 10);\n    var d = new Date();\n    var obj = {\n      year: year,\n      month: d.getMonth(),\n      date: d.getDate()\n    };\n\n    if (hasDate_1(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walk_1(s, obj);\n    s = parseTime_1(s);\n    return s;\n  }\n}];\nvar strParse = strFmt;\nvar dates = {\n  now: function now(s) {\n    s.epoch = Date.now();\n    return s;\n  },\n  tonight: function tonight(s) {\n    s.epoch = Date.now();\n    s = s.hour(18);\n    return s;\n  },\n  today: function today(s) {\n    s.epoch = Date.now();\n    return s;\n  },\n  tomorrow: function tomorrow(s) {\n    s.epoch = Date.now();\n    s = s.add(1, 'day');\n    s = s.startOf('day');\n    return s;\n  },\n  yesterday: function yesterday(s) {\n    s.epoch = Date.now();\n    s = s.subtract(1, 'day');\n    s = s.startOf('day');\n    return s;\n  },\n  christmas: function christmas(s) {\n    var year = new Date().getFullYear();\n    s = s.set([year, 11, 25, 18, 0, 0]); // Dec 25\n\n    return s;\n  },\n  'new years': function newYears(s) {\n    var year = new Date().getFullYear();\n    s = s.set([year, 11, 31, 18, 0, 0]); // Dec 31\n\n    return s;\n  }\n};\ndates['new years eve'] = dates['new years'];\nvar namedDates = dates; //we have to actually parse these inputs ourselves\n//  -  can't use built-in js parser ;(\n//=========================================\n// ISO Date\t  \"2015-03-25\"\n// Short Date\t\"03/25/2015\" or \"2015/03/25\"\n// Long Date\t\"Mar 25 2015\" or \"25 Mar 2015\"\n// Full Date\t\"Wednesday March 25 2015\"\n//=========================================\n//-- also -\n// if the given epoch is really small, they've probably given seconds and not milliseconds\n// anything below this number is likely (but not necessarily) a mistaken input.\n// this may seem like an arbitrary number, but it's 'within jan 1970'\n// this is only really ambiguous until 2054 or so\n\nvar minimumEpoch = 2500000000;\nvar defaults = {\n  year: new Date().getFullYear(),\n  month: 0,\n  date: 1\n}; //support [2016, 03, 01] format\n\nvar handleArray = function handleArray(s, arr) {\n  var order = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond'];\n\n  for (var _i5 = 0; _i5 < order.length; _i5++) {\n    var _num2 = arr[_i5] || defaults[order[_i5]] || 0;\n\n    s = s[order[_i5]](_num2);\n  }\n\n  return s;\n}; //support {year:2016, month:3} format\n\n\nvar handleObject = function handleObject(s, obj) {\n  obj = Object.assign({}, defaults, obj);\n  var keys = Object.keys(obj);\n\n  for (var _i6 = 0; _i6 < keys.length; _i6++) {\n    var unit = keys[_i6]; //make sure we have this method\n\n    if (s[unit] === undefined || typeof s[unit] !== 'function') {\n      continue;\n    } //make sure the value is a number\n\n\n    if (obj[unit] === null || obj[unit] === undefined || obj[unit] === '') {\n      continue;\n    }\n\n    var _num3 = obj[unit] || defaults[unit] || 0;\n\n    s = s[unit](_num3);\n  }\n\n  return s;\n}; //find the epoch from different input styles\n\n\nvar parseInput = function parseInput(s, input, givenTz) {\n  //if we've been given a epoch number, it's easy\n  if (typeof input === 'number') {\n    if (input > 0 && input < minimumEpoch && s.silent === false) {\n      console.warn('  - Warning: You are setting the date to January 1970.');\n      console.warn('       -   did input seconds instead of milliseconds?');\n    }\n\n    s.epoch = input;\n    return s;\n  } //set tmp time\n\n\n  s.epoch = Date.now();\n\n  if (input === null || input === undefined) {\n    return s; //k, we're good.\n  } //support input of Date() object\n\n\n  if (fns.isDate(input) === true) {\n    s.epoch = input.getTime();\n    return s;\n  } //support [2016, 03, 01] format\n\n\n  if (fns.isArray(input) === true) {\n    s = handleArray(s, input);\n    return s;\n  } //support {year:2016, month:3} format\n\n\n  if (fns.isObject(input) === true) {\n    //support spacetime object as input\n    if (input.epoch) {\n      s.epoch = input.epoch;\n      s.tz = input.tz;\n      return s;\n    }\n\n    s = handleObject(s, input);\n    return s;\n  } //input as a string..\n\n\n  if (typeof input !== 'string') {\n    return s;\n  } //little cleanup..\n\n\n  input = input.replace(/\\b(mon|tues|wed|wednes|thu|thurs|fri|sat|satur|sun)(day)?\\b/i, '');\n  input = input.replace(/,/g, '');\n  input = input.replace(/ +/g, ' ').trim(); //try some known-words, like 'now'\n\n  if (namedDates.hasOwnProperty(input) === true) {\n    s = namedDates[input](s);\n    return s;\n  } //try each text-parse template, use the first good result\n\n\n  for (var _i7 = 0; _i7 < strParse.length; _i7++) {\n    var m = input.match(strParse[_i7].reg);\n\n    if (m) {\n      s = strParse[_i7].parse(s, m, givenTz);\n      return s;\n    }\n  }\n\n  if (s.silent === false) {\n    console.warn(\"Warning: couldn't parse date-string: '\" + input + \"'\");\n  }\n\n  s.epoch = null;\n  return s;\n};\n\nvar input = parseInput;\nvar shortDays = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\nvar longDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nvar days = {\n  short: function short() {\n    return shortDays;\n  },\n  long: function long() {\n    return longDays;\n  },\n  set: function set(i18n) {\n    shortDays = i18n.short || shortDays;\n    longDays = i18n.long || longDays;\n  }\n}; // create the timezone offset part of an iso timestamp\n// it's kind of nuts how involved this is\n// \"+01:00\", \"+0100\", or simply \"+01\"\n\nvar isoOffset = function isoOffset(s) {\n  var offset = s.timezone().current.offset;\n  var isNegative = offset < 0;\n  var minute = '00'; //handle 5.5 → '5:30'\n\n  if (Math.abs(offset % 1) === 0.5) {\n    minute = '30';\n\n    if (offset >= 0) {\n      offset = Math.floor(offset);\n    } else {\n      offset = Math.ceil(offset);\n    }\n  }\n\n  if (isNegative) {\n    //handle negative sign\n    offset *= -1;\n    offset = fns.zeroPad(offset, 2);\n    offset = '-' + offset;\n  } else {\n    offset = fns.zeroPad(offset, 2);\n    offset = '+' + offset;\n  }\n\n  offset = offset + ':' + minute; //'Z' means 00\n\n  if (offset === '+00:00') {\n    offset = 'Z';\n  }\n\n  return offset;\n};\n\nvar _offset = isoOffset;\nvar format = {\n  day: function day(s) {\n    return fns.titleCase(s.dayName());\n  },\n  'day-short': function dayShort(s) {\n    return fns.titleCase(days.short()[s.day()]);\n  },\n  'day-number': function dayNumber(s) {\n    return s.day();\n  },\n  'day-ordinal': function dayOrdinal(s) {\n    return fns.ordinal(s.day());\n  },\n  'day-pad': function dayPad(s) {\n    return fns.zeroPad(s.day());\n  },\n  date: function date(s) {\n    return s.date();\n  },\n  'date-ordinal': function dateOrdinal(s) {\n    return fns.ordinal(s.date());\n  },\n  'date-pad': function datePad(s) {\n    return fns.zeroPad(s.date());\n  },\n  month: function month(s) {\n    return fns.titleCase(s.monthName());\n  },\n  'month-short': function monthShort(s) {\n    return fns.titleCase(months.short()[s.month()]);\n  },\n  'month-number': function monthNumber(s) {\n    return s.month();\n  },\n  'month-ordinal': function monthOrdinal(s) {\n    return fns.ordinal(s.month());\n  },\n  'month-pad': function monthPad(s) {\n    return fns.zeroPad(s.month());\n  },\n  'iso-month': function isoMonth(s) {\n    return fns.zeroPad(s.month() + 1);\n  },\n  //1-based months\n  year: function year(s) {\n    var year = s.year();\n\n    if (year > 0) {\n      return year;\n    }\n\n    year = Math.abs(year);\n    return year + ' BC';\n  },\n  'year-short': function yearShort(s) {\n    var year = s.year();\n\n    if (year > 0) {\n      return \"'\".concat(String(s.year()).substr(2, 4));\n    }\n\n    year = Math.abs(year);\n    return year + ' BC';\n  },\n  'iso-year': function isoYear(s) {\n    var year = s.year();\n    var isNegative = year < 0;\n    var str = fns.zeroPad(Math.abs(year), 4); //0-padded\n\n    if (isNegative) {\n      //negative years are for some reason 6-digits ('-00008')\n      str = fns.zeroPad(str, 6);\n      str = '-' + str;\n    }\n\n    return str;\n  },\n  time: function time(s) {\n    return s.time();\n  },\n  'time-24': function time24(s) {\n    return \"\".concat(s.hour24(), \":\").concat(fns.zeroPad(s.minute()));\n  },\n  hour: function hour(s) {\n    return s.hour12();\n  },\n  'hour-pad': function hourPad(s) {\n    return fns.zeroPad(s.hour12());\n  },\n  'hour-24': function hour24(s) {\n    return s.hour24();\n  },\n  'hour-24-pad': function hour24Pad(s) {\n    return fns.zeroPad(s.hour24());\n  },\n  minute: function minute(s) {\n    return s.minute();\n  },\n  'minute-pad': function minutePad(s) {\n    return fns.zeroPad(s.minute());\n  },\n  second: function second(s) {\n    return s.second();\n  },\n  'second-pad': function secondPad(s) {\n    return fns.zeroPad(s.second());\n  },\n  ampm: function ampm(s) {\n    return s.ampm();\n  },\n  quarter: function quarter(s) {\n    return 'Q' + s.quarter();\n  },\n  season: function season(s) {\n    return s.season();\n  },\n  era: function era(s) {\n    return s.era();\n  },\n  timezone: function timezone(s) {\n    return s.timezone().name;\n  },\n  offset: function offset(s) {\n    return _offset(s);\n  },\n  numeric: function numeric(s) {\n    return \"\".concat(s.year(), \"/\").concat(fns.zeroPad(s.month() + 1), \"/\").concat(fns.zeroPad(s.date()));\n  },\n  // yyyy/mm/dd\n  'numeric-us': function numericUs(s) {\n    return \"\".concat(fns.zeroPad(s.month() + 1), \"/\").concat(fns.zeroPad(s.date()), \"/\").concat(s.year());\n  },\n  // mm/dd/yyyy\n  'numeric-uk': function numericUk(s) {\n    return \"\".concat(fns.zeroPad(s.date()), \"/\").concat(fns.zeroPad(s.month() + 1), \"/\").concat(s.year());\n  },\n  //dd/mm/yyyy\n  'mm/dd': function mmDd(s) {\n    return \"\".concat(fns.zeroPad(s.month() + 1), \"/\").concat(fns.zeroPad(s.date()));\n  },\n  //mm/dd\n  // ... https://en.wikipedia.org/wiki/ISO_8601 ;(((\n  iso: function iso(s) {\n    var year = s.format('iso-year');\n    var month = fns.zeroPad(s.month() + 1); //1-based months\n\n    var date = fns.zeroPad(s.date());\n    var hour = fns.zeroPad(s.h24());\n    var minute = fns.zeroPad(s.minute());\n    var second = fns.zeroPad(s.second());\n    var ms = fns.zeroPad(s.millisecond(), 3);\n\n    var offset = _offset(s);\n\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(date, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second, \".\").concat(ms).concat(offset); //2018-03-09T08:50:00.000-05:00\n  },\n  'iso-short': function isoShort(s) {\n    var month = fns.zeroPad(s.month() + 1); //1-based months\n\n    var date = fns.zeroPad(s.date());\n    return \"\".concat(s.year(), \"-\").concat(month, \"-\").concat(date); //2017-02-15\n  },\n  'iso-utc': function isoUtc(s) {\n    return new Date(s.epoch).toISOString(); //2017-03-08T19:45:28.367Z\n  },\n  //i made these up\n  nice: function nice(s) {\n    return \"\".concat(months.short()[s.month()], \" \").concat(fns.ordinal(s.date()), \", \").concat(s.time());\n  },\n  'nice-year': function niceYear(s) {\n    return \"\".concat(months.short()[s.month()], \" \").concat(fns.ordinal(s.date()), \", \").concat(s.year());\n  },\n  'nice-day': function niceDay(s) {\n    return \"\".concat(days.short()[s.day()], \" \").concat(fns.titleCase(months.short()[s.month()]), \" \").concat(fns.ordinal(s.date()));\n  },\n  'nice-full': function niceFull(s) {\n    return \"\".concat(s.dayName(), \" \").concat(fns.titleCase(s.monthName()), \" \").concat(fns.ordinal(s.date()), \", \").concat(s.time());\n  }\n}; //aliases\n\nvar aliases = {\n  'day-name': 'day',\n  'month-name': 'month',\n  'iso 8601': 'iso',\n  'time-h24': 'time-24',\n  'time-12': 'time',\n  'time-h12': 'time',\n  tz: 'timezone',\n  'day-num': 'day-number',\n  'month-num': 'month-number',\n  'month-iso': 'iso-month',\n  'year-iso': 'iso-year',\n  'nice-short': 'nice',\n  mdy: 'numeric-us',\n  dmy: 'numeric-uk',\n  ymd: 'numeric',\n  'yyyy/mm/dd': 'numeric',\n  'mm/dd/yyyy': 'numeric-us',\n  'dd/mm/yyyy': 'numeric-us',\n  'little-endian': 'numeric-uk',\n  'big-endian': 'numeric',\n  'day-nice': 'nice-day'\n};\nObject.keys(aliases).forEach(function (k) {\n  return format[k] = format[aliases[k]];\n});\n\nvar printFormat = function printFormat(s) {\n  var str = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  //don't print anything if it's an invalid date\n  if (s.isValid() !== true) {\n    return '';\n  } //support .format('month')\n\n\n  if (format.hasOwnProperty(str)) {\n    var out = String(format[str](s) || '');\n\n    if (str !== 'ampm') {\n      out = fns.titleCase(out);\n    }\n\n    return out;\n  } //support '{hour}:{minute}' notation\n\n\n  if (str.indexOf('{') !== -1) {\n    var sections = /\\{(.+?)\\}/g;\n    str = str.replace(sections, function (_, fmt) {\n      fmt = fmt.toLowerCase().trim();\n\n      if (format.hasOwnProperty(fmt)) {\n        return String(format[fmt](s) || '');\n      }\n\n      return '';\n    });\n    return str;\n  }\n\n  return s.format('iso-short');\n};\n\nvar format_1 = printFormat;\nvar pad = fns.zeroPad;\nvar formatTimezone = fns.formatTimezone; //parse this insane unix-time-templating thing, from the 19th century\n//http://unicode.org/reports/tr35/tr35-25.html#Date_Format_Patterns\n//time-symbols we support\n\nvar mapping = {\n  G: function G(s) {\n    return s.era();\n  },\n  GG: function GG(s) {\n    return s.era();\n  },\n  GGG: function GGG(s) {\n    return s.era();\n  },\n  GGGG: function GGGG(s) {\n    return s.era() === 'AD' ? 'Anno Domini' : 'Before Christ';\n  },\n  //year\n  y: function y(s) {\n    return s.year();\n  },\n  yy: function yy(s) {\n    //last two chars\n    return parseInt(String(s.year()).substr(2, 4), 10);\n  },\n  yyy: function yyy(s) {\n    return s.year();\n  },\n  yyyy: function yyyy(s) {\n    return s.year();\n  },\n  yyyyy: function yyyyy(s) {\n    return '0' + s.year();\n  },\n  // u: (s) => {},//extended non-gregorian years\n  //quarter\n  Q: function Q(s) {\n    return s.quarter();\n  },\n  QQ: function QQ(s) {\n    return s.quarter();\n  },\n  QQQ: function QQQ(s) {\n    return s.quarter();\n  },\n  QQQQ: function QQQQ(s) {\n    return s.quarter();\n  },\n  //month\n  M: function M(s) {\n    return s.month() + 1;\n  },\n  MM: function MM(s) {\n    return pad(s.month() + 1);\n  },\n  MMM: function MMM(s) {\n    return s.format('month-short');\n  },\n  MMMM: function MMMM(s) {\n    return s.format('month');\n  },\n  //week\n  w: function w(s) {\n    return s.week();\n  },\n  ww: function ww(s) {\n    return pad(s.week());\n  },\n  //week of month\n  // W: (s) => s.week(),\n  //date of month\n  d: function d(s) {\n    return s.date();\n  },\n  dd: function dd(s) {\n    return pad(s.date());\n  },\n  //date of year\n  D: function D(s) {\n    return s.dayOfYear();\n  },\n  DD: function DD(s) {\n    return pad(s.dayOfYear());\n  },\n  DDD: function DDD(s) {\n    return pad(s.dayOfYear(), 3);\n  },\n  // F: (s) => {},//date of week in month\n  // g: (s) => {},//modified julian day\n  //day\n  E: function E(s) {\n    return s.format('day-short');\n  },\n  EE: function EE(s) {\n    return s.format('day-short');\n  },\n  EEE: function EEE(s) {\n    return s.format('day-short');\n  },\n  EEEE: function EEEE(s) {\n    return s.format('day');\n  },\n  EEEEE: function EEEEE(s) {\n    return s.format('day')[0];\n  },\n  e: function e(s) {\n    return s.day();\n  },\n  ee: function ee(s) {\n    return s.day();\n  },\n  eee: function eee(s) {\n    return s.format('day-short');\n  },\n  eeee: function eeee(s) {\n    return s.format('day');\n  },\n  eeeee: function eeeee(s) {\n    return s.format('day')[0];\n  },\n  //am/pm\n  a: function a(s) {\n    return s.ampm().toUpperCase();\n  },\n  aa: function aa(s) {\n    return s.ampm().toUpperCase();\n  },\n  aaa: function aaa(s) {\n    return s.ampm().toUpperCase();\n  },\n  aaaa: function aaaa(s) {\n    return s.ampm().toUpperCase();\n  },\n  //hour\n  h: function h(s) {\n    return s.h12();\n  },\n  hh: function hh(s) {\n    return pad(s.h12());\n  },\n  H: function H(s) {\n    return s.hour();\n  },\n  HH: function HH(s) {\n    return pad(s.hour());\n  },\n  // j: (s) => {},//weird hour format\n  m: function m(s) {\n    return s.minute();\n  },\n  mm: function mm(s) {\n    return pad(s.minute());\n  },\n  s: function s(_s) {\n    return _s.second();\n  },\n  ss: function ss(s) {\n    return pad(s.second());\n  },\n  //milliseconds in the day\n  A: function A(s) {\n    return s.epoch - s.startOf('day').epoch;\n  },\n  //timezone\n  z: function z(s) {\n    return s.timezone().name;\n  },\n  zz: function zz(s) {\n    return s.timezone().name;\n  },\n  zzz: function zzz(s) {\n    return s.timezone().name;\n  },\n  zzzz: function zzzz(s) {\n    return s.timezone().name;\n  },\n  Z: function Z(s) {\n    return formatTimezone(s.timezone().current.offset);\n  },\n  ZZ: function ZZ(s) {\n    return formatTimezone(s.timezone().current.offset);\n  },\n  ZZZ: function ZZZ(s) {\n    return formatTimezone(s.timezone().current.offset);\n  },\n  ZZZZ: function ZZZZ(s) {\n    return formatTimezone(s.timezone().current.offset, ':');\n  }\n};\n\nvar addAlias = function addAlias(char, to, n) {\n  var name = char;\n  var toName = to;\n\n  for (var _i8 = 0; _i8 < n; _i8 += 1) {\n    mapping[name] = mapping[toName];\n    name += char;\n    toName += to;\n  }\n};\n\naddAlias('q', 'Q', 4);\naddAlias('L', 'M', 4);\naddAlias('Y', 'y', 4);\naddAlias('c', 'e', 4);\naddAlias('k', 'H', 2);\naddAlias('K', 'h', 2);\naddAlias('S', 's', 2);\naddAlias('v', 'z', 4);\naddAlias('V', 'Z', 4);\n\nvar unixFmt = function unixFmt(s, str) {\n  var chars = str.split(''); //combine consecutive chars, like 'yyyy' as one.\n\n  var arr = [chars[0]];\n  var quoteOn = false;\n\n  for (var _i9 = 1; _i9 < chars.length; _i9 += 1) {\n    //support quoted substrings\n    if (chars[_i9] === \"'\") {\n      quoteOn = !quoteOn; //support '', meaning one tick\n\n      if (quoteOn === true && chars[_i9 + 1] && chars[_i9 + 1] === \"'\") {\n        quoteOn = true;\n      } else {\n        continue;\n      }\n    } //merge it with the last one\n\n\n    if (quoteOn === true || chars[_i9] === arr[arr.length - 1][0]) {\n      arr[arr.length - 1] += chars[_i9];\n    } else {\n      arr.push(chars[_i9]);\n    }\n  }\n\n  return arr.reduce(function (txt, c) {\n    if (mapping[c] !== undefined) {\n      txt += mapping[c](s) || '';\n    } else {\n      txt += c;\n    }\n\n    return txt;\n  }, '');\n};\n\nvar unixFmt_1 = unixFmt;\nvar units$1 = ['year', 'season', 'quarter', 'month', 'week', 'day', 'quarterHour', 'hour', 'minute'];\n\nvar doUnit = function doUnit(s, k) {\n  var start = s.clone().startOf(k);\n  var end = s.clone().endOf(k);\n  var duration = end.epoch - start.epoch;\n  var percent = (s.epoch - start.epoch) / duration;\n  return parseFloat(percent.toFixed(2));\n}; //how far it is along, from 0-1\n\n\nvar progress = function progress(s, unit) {\n  if (unit) {\n    unit = fns.normalize(unit);\n    return doUnit(s, unit);\n  }\n\n  var obj = {};\n  units$1.forEach(function (k) {\n    obj[k] = doUnit(s, k);\n  });\n  return obj;\n};\n\nvar progress_1 = progress; //round to either current, or +1 of this unit\n\nvar nearest = function nearest(s, unit) {\n  //how far have we gone?\n  var prog = s.progress();\n  unit = fns.normalize(unit); //fix camel-case for this one\n\n  if (unit === 'quarterhour') {\n    unit = 'quarterHour';\n  }\n\n  if (prog[unit] !== undefined) {\n    // go forward one?\n    if (prog[unit] > 0.5) {\n      s = s.add(1, unit);\n    } // go to start\n\n\n    s = s.startOf(unit);\n  } else if (s.silent === false) {\n    console.warn(\"no known unit '\" + unit + \"'\");\n  }\n\n  return s;\n};\n\nvar nearest_1 = nearest; //increment until dates are the same\n\nvar climb = function climb(a, b, unit) {\n  var i = 0;\n  a = a.clone();\n\n  while (a.isBefore(b)) {\n    //do proper, expensive increment to catch all-the-tricks\n    a = a.add(1, unit);\n    i += 1;\n  } //oops, we went too-far..\n\n\n  if (a.isAfter(b, unit)) {\n    i -= 1;\n  }\n\n  return i;\n}; // do a thurough +=1 on the unit, until they match\n// for speed-reasons, only used on day, month, week.\n\n\nvar diffOne = function diffOne(a, b, unit) {\n  if (a.isBefore(b)) {\n    return climb(a, b, unit);\n  } else {\n    return climb(b, a, unit) * -1; //reverse it\n  }\n};\n\nvar one = diffOne; // don't do anything too fancy here.\n// 2020 - 2019 may be 1 year, or 0 years\n// - '1 year difference' means 366 days during a leap year\n\nvar fastYear = function fastYear(a, b) {\n  var years = b.year() - a.year(); // should we decrement it by 1?\n\n  a = a.year(b.year());\n\n  if (a.isAfter(b)) {\n    years -= 1;\n  }\n\n  return years;\n}; // use a waterfall-method for computing a diff of any 'pre-knowable' units\n// compute years, then compute months, etc..\n// ... then ms-math for any very-small units\n\n\nvar diff = function diff(a, b) {\n  // an hour is always the same # of milliseconds\n  // so these units can be 'pre-calculated'\n  var msDiff = b.epoch - a.epoch;\n  var obj = {\n    milliseconds: msDiff,\n    seconds: parseInt(msDiff / 1000, 10)\n  };\n  obj.minutes = parseInt(obj.seconds / 60, 10);\n  obj.hours = parseInt(obj.minutes / 60, 10); //do the year\n\n  var tmp = a.clone();\n  obj.years = fastYear(tmp, b);\n  tmp = a.add(obj.years, 'year'); //there's always 12 months in a year...\n\n  obj.months = obj.years * 12;\n  tmp = a.add(obj.months, 'month');\n  obj.months += one(tmp, b, 'month'); // there's always atleast 52 weeks in a year..\n  // (month * 4) isn't as close\n\n  obj.weeks = obj.years * 52;\n  tmp = a.add(obj.weeks, 'week');\n  obj.weeks += one(tmp, b, 'week'); // there's always atleast 7 days in a week\n\n  obj.days = obj.weeks * 7;\n  tmp = a.add(obj.days, 'day');\n  obj.days += one(tmp, b, 'day');\n  return obj;\n};\n\nvar waterfall = diff;\n\nvar reverseDiff = function reverseDiff(obj) {\n  Object.keys(obj).forEach(function (k) {\n    obj[k] *= -1;\n  });\n  return obj;\n}; // this method counts a total # of each unit, between a, b.\n// '1 month' means 28 days in february\n// '1 year' means 366 days in a leap year\n\n\nvar main = function main(a, b, unit) {\n  b = fns.beADate(b, a); //reverse values, if necessary\n\n  var reversed = false;\n\n  if (a.isAfter(b)) {\n    var tmp = a;\n    a = b;\n    b = tmp;\n    reversed = true;\n  } //compute them all (i know!)\n\n\n  var obj = waterfall(a, b);\n\n  if (reversed) {\n    obj = reverseDiff(obj);\n  } //return just the requested unit\n\n\n  if (unit) {\n    //make sure it's plural-form\n    unit = fns.normalize(unit);\n\n    if (/s$/.test(unit) !== true) {\n      unit += 's';\n    }\n\n    if (unit === 'dates') {\n      unit = 'days';\n    }\n\n    return obj[unit];\n  }\n\n  return obj;\n};\n\nvar diff$1 = main; //by spencermountain + Shaun Grady\n//our conceptual 'break-points' for each unit\n\nvar qualifiers = {\n  months: {\n    almost: 10,\n    over: 4\n  },\n  days: {\n    almost: 25,\n    over: 10\n  },\n  hours: {\n    almost: 20,\n    over: 8\n  },\n  minutes: {\n    almost: 50,\n    over: 20\n  },\n  seconds: {\n    almost: 50,\n    over: 20\n  }\n}; //get number of hours/minutes... between the two dates\n\nfunction getDiff(a, b) {\n  var isBefore = a.isBefore(b);\n  var later = isBefore ? b : a;\n  var earlier = isBefore ? a : b;\n  earlier = earlier.clone();\n  var diff = {\n    years: 0,\n    months: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0\n  };\n  Object.keys(diff).forEach(function (unit) {\n    if (earlier.isSame(later, unit)) {\n      return;\n    }\n\n    var max = earlier.diff(later, unit);\n    earlier = earlier.add(max, unit);\n    diff[unit] = max;\n  }); //reverse it, if necessary\n\n  if (isBefore) {\n    Object.keys(diff).forEach(function (u) {\n      if (diff[u] !== 0) {\n        diff[u] *= -1;\n      }\n    });\n  }\n\n  return diff;\n} // Expects a plural unit arg\n\n\nfunction pluralize(value, unit) {\n  if (value === 1) {\n    unit = unit.slice(0, -1);\n  }\n\n  return value + ' ' + unit;\n} //create the human-readable diff between the two dates\n\n\nvar since = function since(start, end) {\n  end = fns.beADate(end, start);\n  var diff = getDiff(start, end);\n  var isNow = Object.keys(diff).every(function (u) {\n    return !diff[u];\n  });\n\n  if (isNow === true) {\n    return {\n      diff: diff,\n      rounded: 'now',\n      qualified: 'now',\n      precise: 'now'\n    };\n  }\n\n  var rounded;\n  var qualified;\n  var precise;\n  var englishValues = []; //go through each value and create its text-representation\n\n  Object.keys(diff).forEach(function (unit, i, units) {\n    var value = Math.abs(diff[unit]);\n\n    if (value === 0) {\n      return;\n    }\n\n    var englishValue = pluralize(value, unit);\n    englishValues.push(englishValue);\n\n    if (!rounded) {\n      rounded = qualified = englishValue;\n\n      if (i > 4) {\n        return;\n      } //is it a 'almost' something, etc?\n\n\n      var nextUnit = units[i + 1];\n      var nextValue = Math.abs(diff[nextUnit]);\n\n      if (nextValue > qualifiers[nextUnit].almost) {\n        rounded = pluralize(value + 1, unit);\n        qualified = 'almost ' + rounded;\n      } else if (nextValue > qualifiers[nextUnit].over) qualified = 'over ' + englishValue;\n    }\n  }); //make them into a string\n\n  precise = englishValues.splice(0, 2).join(', '); //handle before/after logic\n\n  if (start.isAfter(end) === true) {\n    rounded += ' ago';\n    qualified += ' ago';\n    precise += ' ago';\n  } else {\n    rounded = 'in ' + rounded;\n    qualified = 'in ' + qualified;\n    precise = 'in ' + precise;\n  }\n\n  return {\n    diff: diff,\n    rounded: rounded,\n    qualified: qualified,\n    precise: precise\n  };\n};\n\nvar since_1 = since; //https://www.timeanddate.com/calendar/aboutseasons.html\n// Spring - from March 1 to May 31;\n// Summer - from June 1 to August 31;\n// Fall (autumn) - from September 1 to November 30; and,\n// Winter - from December 1 to February 28 (February 29 in a leap year).\n\nvar seasons = {\n  north: [['spring', 2, 1], //spring march 1\n  ['summer', 5, 1], //june 1\n  ['fall', 8, 1], //sept 1\n  ['autumn', 8, 1], //sept 1\n  ['winter', 11, 1] //dec 1\n  ],\n  south: [['fall', 2, 1], //march 1\n  ['autumn', 2, 1], //march 1\n  ['winter', 5, 1], //june 1\n  ['spring', 8, 1], //sept 1\n  ['summer', 11, 1] //dec 1\n  ]\n};\nvar quarters = [null, [0, 1], //jan 1\n[3, 1], //apr 1\n[6, 1], //july 1\n[9, 1] //oct 1\n];\nvar units$2 = {\n  minute: function minute(s) {\n    walk_1(s, {\n      second: 0,\n      millisecond: 0\n    });\n    return s;\n  },\n  quarterhour: function quarterhour(s) {\n    var minute = s.minutes();\n\n    if (minute >= 45) {\n      s = s.minutes(45);\n    } else if (minute >= 30) {\n      s = s.minutes(30);\n    } else if (minute >= 15) {\n      s = s.minutes(15);\n    } else {\n      s = s.minutes(0);\n    }\n\n    walk_1(s, {\n      second: 0,\n      millisecond: 0\n    });\n    return s;\n  },\n  hour: function hour(s) {\n    walk_1(s, {\n      minute: 0,\n      second: 0,\n      millisecond: 0\n    });\n    return s;\n  },\n  day: function day(s) {\n    walk_1(s, {\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisecond: 0\n    });\n    return s;\n  },\n  week: function week(s) {\n    var original = s.clone();\n    s = s.day(s._weekStart); //monday\n\n    if (s.isAfter(original)) {\n      s = s.subtract(1, 'week');\n    }\n\n    walk_1(s, {\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisecond: 0\n    });\n    return s;\n  },\n  month: function month(s) {\n    walk_1(s, {\n      date: 1,\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisecond: 0\n    });\n    return s;\n  },\n  quarter: function quarter(s) {\n    var q = s.quarter();\n\n    if (quarters[q]) {\n      walk_1(s, {\n        month: quarters[q][0],\n        date: quarters[q][1],\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0\n      });\n    }\n\n    return s;\n  },\n  season: function season(s) {\n    var current = s.season();\n    var hem = 'north';\n\n    if (s.hemisphere() === 'South') {\n      hem = 'south';\n    }\n\n    for (var _i10 = 0; _i10 < seasons[hem].length; _i10++) {\n      if (seasons[hem][_i10][0] === current) {\n        //winter goes between years\n        var year = s.year();\n\n        if (current === 'winter' && s.month() < 3) {\n          year -= 1;\n        }\n\n        walk_1(s, {\n          year: year,\n          month: seasons[hem][_i10][1],\n          date: seasons[hem][_i10][2],\n          hour: 0,\n          minute: 0,\n          second: 0,\n          millisecond: 0\n        });\n        return s;\n      }\n    }\n\n    return s;\n  },\n  year: function year(s) {\n    walk_1(s, {\n      month: 0,\n      date: 1,\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisecond: 0\n    });\n    return s;\n  },\n  decade: function decade(s) {\n    s = s.startOf('year');\n    var year = s.year();\n    var decade = parseInt(year / 10, 10) * 10;\n    s = s.year(decade);\n    return s;\n  },\n  century: function century(s) {\n    s = s.startOf('year');\n    var year = s.year();\n    var decade = parseInt(year / 100, 10) * 100;\n    s = s.year(decade);\n    return s;\n  }\n};\nunits$2.date = units$2.day;\n\nvar startOf = function startOf(a, unit) {\n  var s = a.clone();\n  unit = fns.normalize(unit);\n\n  if (units$2[unit]) {\n    return units$2[unit](s);\n  }\n\n  if (unit === 'summer' || unit === 'winter') {\n    s = s.season(unit);\n    return units$2.season(s);\n  }\n\n  return s;\n}; //piggy-backs off startOf\n\n\nvar endOf = function endOf(a, unit) {\n  var s = a.clone();\n  unit = fns.normalize(unit);\n\n  if (units$2[unit]) {\n    s = units$2[unit](s);\n    s = s.add(1, unit);\n    s = s.subtract(1, 'milliseconds');\n    return s;\n  }\n\n  return s;\n};\n\nvar startOf_1 = {\n  startOf: startOf,\n  endOf: endOf\n}; //is it 'wednesday'?\n\nvar isDay = function isDay(unit) {\n  if (days.short().find(function (s) {\n    return s === unit;\n  })) {\n    return true;\n  }\n\n  if (days.long().find(function (s) {\n    return s === unit;\n  })) {\n    return true;\n  }\n\n  return false;\n}; // return a list of the weeks/months/days between a -> b\n// returns spacetime objects in the timezone of the input\n\n\nvar every = function every(start) {\n  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (!unit || !end) {\n    return [];\n  } //cleanup unit param\n\n\n  unit = fns.normalize(unit); //cleanup to param\n\n  end = start.clone().set(end); //swap them, if they're backwards\n\n  if (start.isAfter(end)) {\n    var tmp = start;\n    start = end;\n    end = tmp;\n  } //support 'every wednesday'\n\n\n  var d = start.clone();\n\n  if (isDay(unit)) {\n    d = d.next(unit);\n    unit = 'week';\n  } else {\n    d = d.next(unit);\n  } //okay, actually start doing it\n\n\n  var result = [];\n\n  while (d.isBefore(end)) {\n    result.push(d);\n    d = d.add(1, unit);\n  }\n\n  return result;\n};\n\nvar every_1 = every;\nvar informal$2 = informal_1.informal; //these timezone abbreviations are used aggressively in other places\n//if tz doesn't have an abbreviation, and is in the same offset...\n//these are pretty subjective. i just made them up.\n\nvar greedy_north = {\n  '-8': 'america/anchorage',\n  '-7': 'america/los_angeles',\n  '-6': 'america/denver',\n  '-5': 'america/chicago',\n  '-4': 'america/new_york',\n  '-3': 'america/halifax',\n  '0': 'etc/gmt',\n  '1': 'europe/lisbon',\n  '2': 'europe/berlin',\n  // '3': 'europe/riga',\n  // '3': 'europe/moscow',\n  '8': 'asia/shanghai'\n};\nvar greedy_south = {\n  '-3': 'america/sao_paulo',\n  '0': 'etc/gmt',\n  '1': 'africa/lagos',\n  // '2': 'africa/khartoum',//central africa\n  '2': 'africa/johannesburg',\n  //south africa\n  '3': 'africa/nairobi',\n  '10': 'australia/brisbane',\n  '12': 'pacific/auckland'\n};\nvar british = {\n  'europe/belfast': true,\n  'europe/dublin': true,\n  'europe/guernsey': true,\n  'europe/jersey': true\n};\n\nvar handleSpecial = function handleSpecial(tz, offset) {\n  if (british.hasOwnProperty(tz)) {\n    if (offset === '1') {\n      return 'BST';\n    }\n\n    return 'GMT';\n  }\n\n  return null;\n};\n\nvar chooseAbbrev = function chooseAbbrev(arr, obj) {\n  if (arr[1] && obj.current.isDST === true) {\n    return arr[1].toUpperCase();\n  }\n\n  if (arr[0]) {\n    return arr[0].toUpperCase();\n  }\n\n  return null;\n}; //\n\n\nvar display = function display(tz, obj) {\n  //try a straight-up match\n  if (informal$2.hasOwnProperty(tz)) {\n    var abbr = chooseAbbrev(informal$2[tz], obj);\n\n    if (abbr !== null) {\n      return abbr;\n    }\n  }\n\n  var offset = String(obj.default_offset);\n  var special = handleSpecial(tz, offset);\n\n  if (special) {\n    return special;\n  }\n\n  if (obj.hemisphere === 'North' && greedy_north.hasOwnProperty(offset)) {\n    var useTz = greedy_north[offset];\n    return chooseAbbrev(informal$2[useTz], obj) || '';\n  }\n\n  if (obj.hemisphere === 'South' && greedy_south.hasOwnProperty(offset)) {\n    var _useTz = greedy_south[offset];\n    return chooseAbbrev(informal$2[_useTz], obj) || '';\n  }\n\n  return '';\n};\n\nvar display_1 = display;\n\nvar parseDst = function parseDst(dst) {\n  if (!dst) {\n    return [];\n  }\n\n  return dst.split('->');\n};\n\nvar titleCase = function titleCase(str) {\n  str = str[0].toUpperCase() + str.substr(1);\n  str = str.replace(/\\/gmt/, '/GMT');\n  str = str.replace(/[\\/_]([a-z])/gi, function (s) {\n    return s.toUpperCase();\n  });\n  return str;\n}; //get metadata about this timezone\n\n\nvar timezone = function timezone(s) {\n  var zones = s.timezones;\n  var tz = s.tz;\n\n  if (zones.hasOwnProperty(tz) === false) {\n    tz = find(s.tz, zones);\n  }\n\n  if (tz === null) {\n    if (s.silent === false) {\n      console.warn(\"Warn: could not find given or local timezone - '\" + s.tz + \"'\");\n    }\n\n    return {\n      current: {\n        epochShift: 0\n      }\n    };\n  }\n\n  var found = zones[tz];\n  var result = {\n    name: titleCase(tz),\n    hasDst: Boolean(found.dst),\n    default_offset: found.offset,\n    //do north-hemisphere version as default (sorry!)\n    hemisphere: found.hem === 's' ? 'South' : 'North',\n    current: {}\n  };\n\n  if (result.hasDst) {\n    var arr = parseDst(found.dst);\n    result.change = {\n      start: arr[0],\n      back: arr[1]\n    };\n  } //find the offsets for summer/winter times\n  //(these variable names are north-centric)\n\n\n  var summer = found.offset; // (july)\n\n  var winter = summer; // (january) assume it's the same for now\n\n  if (result.hasDst === true) {\n    if (result.hemisphere === 'North') {\n      winter = summer - 1;\n    } else {\n      //southern hemisphere\n      winter = found.offset + 1;\n    }\n  } //find out which offset to use right now\n  //use 'summer' time july-time\n\n\n  if (result.hasDst === false) {\n    result.current.offset = summer;\n    result.current.isDST = false;\n  } else if (summerTime(s.epoch, result.change.start, result.change.back, summer) === true) {\n    result.current.offset = summer;\n    result.current.isDST = result.hemisphere === 'North'; //dst 'on' in winter in north\n  } else {\n    //use 'winter' january-time\n    result.current.offset = winter;\n    result.current.isDST = result.hemisphere === 'South'; //dst 'on' in summer in south\n  } //try to find the best name for it..\n\n\n  result.display = display_1(tz, result);\n  return result;\n};\n\nvar timezone_1 = timezone; //the spacetime instance methods (also, the API)\n\nvar methods = {\n  set: function set(input$1, tz) {\n    var s = this.clone();\n    s = input(s, input$1);\n\n    if (tz) {\n      this.tz = find(tz);\n    }\n\n    return s;\n  },\n  timezone: function timezone() {\n    return timezone_1(this);\n  },\n  isDST: function isDST() {\n    return timezone_1(this).current.isDST;\n  },\n  hasDST: function hasDST() {\n    return timezone_1(this).hasDst;\n  },\n  offset: function offset() {\n    return timezone_1(this).current.offset * 60;\n  },\n  hemisphere: function hemisphere() {\n    return timezone_1(this).hemisphere;\n  },\n  format: function format(fmt) {\n    return format_1(this, fmt);\n  },\n  unixFmt: function unixFmt(fmt) {\n    return unixFmt_1(this, fmt);\n  },\n  startOf: function startOf(unit) {\n    return startOf_1.startOf(this, unit);\n  },\n  endOf: function endOf(unit) {\n    return startOf_1.endOf(this, unit);\n  },\n  leapYear: function leapYear() {\n    var year = this.year();\n    return fns.isLeapYear(year);\n  },\n  progress: function progress(unit) {\n    return progress_1(this, unit);\n  },\n  nearest: function nearest(unit) {\n    return nearest_1(this, unit);\n  },\n  diff: function diff(d, unit) {\n    return diff$1(this, d, unit);\n  },\n  since: function since(d) {\n    if (!d) {\n      d = this.clone().set();\n    }\n\n    return since_1(this, d);\n  },\n  next: function next(unit) {\n    var s = this.add(1, unit);\n    return s.startOf(unit);\n  },\n  //the start of the previous year/week/century\n  last: function last(unit) {\n    var s = this.subtract(1, unit);\n    return s.startOf(unit);\n  },\n  isValid: function isValid() {\n    //null/undefined epochs\n    if (!this.epoch && this.epoch !== 0) {\n      return false;\n    }\n\n    return !isNaN(this.d.getTime());\n  },\n  //travel to this timezone\n  goto: function goto(tz) {\n    var s = this.clone();\n    s.tz = find(tz, s.timezones); //science!\n\n    return s;\n  },\n  //get each week/month/day between a -> b\n  every: function every(unit, to) {\n    return every_1(this, unit, to);\n  },\n  isAwake: function isAwake() {\n    var hour = this.hour(); //10pm -> 8am\n\n    if (hour < 8 || hour > 22) {\n      return false;\n    }\n\n    return true;\n  },\n  isAsleep: function isAsleep() {\n    return !this.isAwake();\n  },\n  //pretty-printing\n  log: function log() {\n    console.log('');\n    console.log(format_1(this, 'nice-short'));\n    return this;\n  },\n  logYear: function logYear() {\n    console.log('');\n    console.log(format_1(this, 'full-short'));\n    return this;\n  },\n  debug: function debug() {\n    var tz = this.timezone();\n    var date = this.format('MM') + ' ' + this.format('date-ordinal') + ' ' + this.year();\n    date += '\\n     - ' + this.format('time');\n    console.log('\\n\\n', date + '\\n     - ' + tz.name + ' (' + tz.current.offset + ')');\n    return this;\n  },\n  //alias of 'since' but opposite - like moment.js\n  from: function from(d) {\n    d = this.clone().set(d);\n    return d.since(this);\n  },\n  fromNow: function fromNow() {\n    var d = this.clone().set(Date.now());\n    return d.since(this);\n  },\n  weekStart: function weekStart(input) {\n    //accept a number directly\n    if (typeof input === 'number') {\n      this._weekStart = input;\n      return this;\n    }\n\n    if (typeof input === 'string') {\n      // accept 'wednesday'\n      input = input.toLowerCase().trim();\n\n      var _num4 = days.short().indexOf(input);\n\n      if (_num4 === -1) {\n        _num4 = days.long().indexOf(input);\n      }\n\n      if (_num4 === -1) {\n        _num4 = 1; //go back to default\n      }\n\n      this._weekStart = _num4;\n    } else {\n      console.warn('Spacetime Error: Cannot understand .weekStart() input:', input);\n    }\n\n    return this;\n  }\n}; // aliases\n\nmethods.inDST = methods.isDST;\nmethods.round = methods.nearest;\nmethods.each = methods.every;\nvar methods_1 = methods; // javascript setX methods like setDate() can't be used because of the local bias\n//these methods wrap around them.\n\nvar validate = function validate(n) {\n  //handle number as a string\n  if (typeof n === 'string') {\n    n = parseInt(n, 10);\n  }\n\n  return n;\n};\n\nvar order = ['year', 'month', 'date', 'hour', 'minute', 'second', 'millisecond']; //reduce hostile micro-changes when moving dates by millisecond\n\nvar confirm = function confirm(s, tmp, unit) {\n  var n = order.indexOf(unit);\n  var arr = order.slice(n, order.length);\n\n  for (var _i11 = 0; _i11 < arr.length; _i11++) {\n    var want = tmp[arr[_i11]]();\n\n    s[arr[_i11]](want);\n  }\n\n  return s;\n};\n\nvar set = {\n  milliseconds: function milliseconds(s, n) {\n    n = validate(n);\n    var current = s.millisecond();\n    var diff = current - n; //milliseconds to shift by\n\n    return s.epoch - diff;\n  },\n  seconds: function seconds(s, n) {\n    n = validate(n);\n    var diff = s.second() - n;\n    var shift = diff * milliseconds.second;\n    return s.epoch - shift;\n  },\n  minutes: function minutes(s, n) {\n    n = validate(n);\n    var old = s.clone();\n    var diff = s.minute() - n;\n    var shift = diff * milliseconds.minute;\n    s.epoch -= shift;\n    confirm(s, old, 'second');\n    return s.epoch;\n  },\n  hours: function hours(s, n) {\n    n = validate(n);\n\n    if (n >= 24) {\n      n = 24;\n    } else if (n < 0) {\n      n = 0;\n    }\n\n    var old = s.clone();\n    var diff = s.hour() - n;\n    var shift = diff * milliseconds.hour;\n    s.epoch -= shift;\n    walk_1(s, {\n      hour: n\n    });\n    confirm(s, old, 'minute');\n    return s.epoch;\n  },\n  //support setting time by '4:25pm' - this isn't very-well developed..\n  time: function time(s, str) {\n    var m = str.match(/([0-9]{1,2}):([0-9]{1,2})(am|pm)?/);\n\n    if (!m) {\n      //fallback to support just '2am'\n      m = str.match(/([0-9]{1,2})(am|pm)/);\n\n      if (!m) {\n        return s.epoch;\n      }\n\n      m.splice(2, 0, '0'); //add implicit 0 minutes\n    }\n\n    var h24 = false;\n    var hour = parseInt(m[1], 10);\n    var minute = parseInt(m[2], 10);\n\n    if (hour > 12) {\n      h24 = true;\n    } //make the hour into proper 24h time\n\n\n    if (h24 === false) {\n      if (m[3] === 'am' && hour === 12) {\n        //12am is midnight\n        hour = 0;\n      }\n\n      if (m[3] === 'pm' && hour < 12) {\n        //12pm is noon\n        hour += 12;\n      }\n    }\n\n    s = s.hour(hour);\n    s = s.minute(minute);\n    s = s.second(0);\n    s = s.millisecond(0);\n    return s.epoch;\n  },\n  date: function date(s, n) {\n    n = validate(n); //avoid setting february 31st\n\n    if (n > 28) {\n      var max = monthLengths_1[s.month()];\n\n      if (n > max) {\n        n = max;\n      }\n    } //avoid setting < 0\n\n\n    if (n <= 0) {\n      n = 1;\n    }\n\n    walk_1(s, {\n      date: n\n    });\n    return s.epoch;\n  },\n  //this one's tricky\n  month: function month(s, n) {\n    if (typeof n === 'string') {\n      n = months.mapping()[n.toLowerCase()];\n    }\n\n    n = validate(n); //don't go past december\n\n    if (n >= 12) {\n      n = 11;\n    }\n\n    if (n <= 0) {\n      n = 0;\n    }\n\n    var date = s.date(); //there's no 30th of february, etc.\n\n    if (date > monthLengths_1[n]) {\n      //make it as close as we can..\n      date = monthLengths_1[n];\n    }\n\n    walk_1(s, {\n      month: n,\n      date: date\n    });\n    return s.epoch;\n  },\n  year: function year(s, n) {\n    n = validate(n);\n    walk_1(s, {\n      year: n\n    });\n    return s.epoch;\n  },\n  dayOfYear: function dayOfYear(s, n) {\n    n = validate(n);\n    var old = s.clone();\n    n -= 1; //days are 1-based\n\n    if (n <= 0) {\n      n = 0;\n    } else if (n >= 365) {\n      n = 364;\n    }\n\n    s = s.startOf('year');\n    s = s.add(n, 'day');\n    confirm(s, old, 'hour');\n    return s.epoch;\n  }\n};\nvar methods$1 = {\n  millisecond: function millisecond(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n      s.epoch = set.milliseconds(s, num);\n      return s;\n    }\n\n    return this.d.getMilliseconds();\n  },\n  second: function second(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n      s.epoch = set.seconds(s, num);\n      return s;\n    }\n\n    return this.d.getSeconds();\n  },\n  minute: function minute(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n      s.epoch = set.minutes(s, num);\n      return s;\n    }\n\n    return this.d.getMinutes();\n  },\n  hour: function hour(num) {\n    var d = this.d;\n\n    if (num !== undefined) {\n      var s = this.clone();\n      s.epoch = set.hours(s, num);\n      return s;\n    }\n\n    return d.getHours();\n  },\n  //'3:30' is 3.5\n  hourFloat: function hourFloat(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n\n      var _minute = num % 1;\n\n      _minute = _minute * 60;\n\n      var _hour = parseInt(num, 10);\n\n      s.epoch = set.hours(s, _hour);\n      s.epoch = set.minutes(s, _minute);\n      return s;\n    }\n\n    var d = this.d;\n    var hour = d.getHours();\n    var minute = d.getMinutes();\n    minute = minute / 60;\n    return hour + minute;\n  },\n  // hour in 12h format\n  hour12: function hour12(str) {\n    var d = this.d;\n\n    if (str !== undefined) {\n      var s = this.clone();\n      str = '' + str;\n      var m = str.match(/^([0-9]+)(am|pm)$/);\n\n      if (m) {\n        var hour = parseInt(m[1], 10);\n\n        if (m[2] === 'pm') {\n          hour += 12;\n        }\n\n        s.epoch = set.hours(s, hour);\n      }\n\n      return s;\n    } //get the hour\n\n\n    var hour12 = d.getHours();\n\n    if (hour12 > 12) {\n      hour12 = hour12 - 12;\n    }\n\n    if (hour12 === 0) {\n      hour12 = 12;\n    }\n\n    return hour12;\n  },\n  //some ambiguity here with 12/24h\n  time: function time(str) {\n    if (str !== undefined) {\n      var s = this.clone();\n      s.epoch = set.time(s, str);\n      return s;\n    }\n\n    return \"\".concat(this.h12(), \":\").concat(fns.zeroPad(this.minute())).concat(this.ampm());\n  },\n  // either 'am' or 'pm'\n  ampm: function ampm(input) {\n    var which = 'am';\n    var hour = this.hour();\n\n    if (hour >= 12) {\n      which = 'pm';\n    }\n\n    if (typeof input !== 'string') {\n      return which;\n    } //okay, we're doing a setter\n\n\n    var s = this.clone();\n    input = input.toLowerCase().trim(); //ampm should never change the day\n    // - so use `.hour(n)` instead of `.minus(12,'hour')`\n\n    if (hour >= 12 && input === 'am') {\n      //noon is 12pm\n      hour -= 12;\n      return s.hour(hour);\n    }\n\n    if (hour < 12 && input === 'pm') {\n      hour += 12;\n      return s.hour(hour);\n    }\n\n    return s;\n  },\n  //some hard-coded times of day, like 'noon'\n  dayTime: function dayTime(str) {\n    if (str !== undefined) {\n      var times = {\n        morning: '7:00am',\n        breakfast: '7:00am',\n        noon: '12:00am',\n        lunch: '12:00pm',\n        afternoon: '2:00pm',\n        evening: '6:00pm',\n        dinner: '6:00pm',\n        night: '11:00pm',\n        midnight: '23:59pm'\n      };\n      var s = this.clone();\n      str = str || '';\n      str = str.toLowerCase();\n\n      if (times.hasOwnProperty(str) === true) {\n        s = s.time(times[str]);\n      }\n\n      return s;\n    }\n\n    var h = this.hour();\n\n    if (h < 6) {\n      return 'night';\n    }\n\n    if (h < 12) {\n      //until noon\n      return 'morning';\n    }\n\n    if (h < 17) {\n      //until 5pm\n      return 'afternoon';\n    }\n\n    if (h < 22) {\n      //until 10pm\n      return 'evening';\n    }\n\n    return 'night';\n  },\n  //parse a proper iso string\n  iso: function iso(num) {\n    if (num !== undefined) {\n      return this.set(num);\n    }\n\n    return this.format('iso');\n  }\n};\nvar _01Time = methods$1;\n\nvar clearMinutes = function clearMinutes(s) {\n  s = s.minute(0);\n  s = s.second(0);\n  s = s.millisecond(1);\n  return s;\n};\n\nvar methods$2 = {\n  // # day in the month\n  date: function date(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n      s.epoch = set.date(s, num);\n      return s;\n    }\n\n    return this.d.getDate();\n  },\n  //like 'wednesday' (hard!)\n  day: function day(input) {\n    if (input === undefined) {\n      return this.d.getDay();\n    }\n\n    var original = this.clone();\n    var want = input; // accept 'wednesday'\n\n    if (typeof input === 'string') {\n      input = input.toLowerCase();\n      want = days.short().indexOf(input);\n\n      if (want === -1) {\n        want = days.long().indexOf(input);\n      }\n    } //move approx\n\n\n    var day = this.d.getDay();\n    var diff = day - want;\n    var s = this.subtract(diff * 24, 'hours'); //tighten it back up\n\n    walk_1(s, {\n      hour: original.hour(),\n      minute: original.minute(),\n      second: original.second()\n    });\n    return s;\n  },\n  //these are helpful name-wrappers\n  dayName: function dayName(input) {\n    if (input === undefined) {\n      return days.long()[this.day()];\n    }\n\n    var s = this.clone();\n    s = s.day(input);\n    return s;\n  },\n  //since the start of the year\n  week: function week(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n      s = s.month(0);\n      s = s.date(1);\n      s = s.day('monday');\n      s = clearMinutes(s); //don't go into last-year\n\n      if (s.monthName() === 'december') {\n        s = s.add(1, 'week');\n      }\n\n      num -= 1; //1-based\n\n      s = s.add(num, 'weeks');\n      return s;\n    } //find-out which week it is\n\n\n    var tmp = this.clone();\n    tmp = tmp.month(0);\n    tmp = tmp.date(1);\n    tmp = clearMinutes(tmp);\n    tmp = tmp.day('monday'); //don't go into last-year\n\n    if (tmp.monthName() === 'december') {\n      tmp = tmp.add(1, 'week');\n    }\n\n    var thisOne = this.epoch; //if the week technically hasn't started yet\n\n    if (tmp.epoch > thisOne) {\n      return 1;\n    }\n\n    for (var _i12 = 0; _i12 < 52; _i12++) {\n      if (tmp.epoch > thisOne) {\n        return _i12;\n      }\n\n      tmp = tmp.add(1, 'week');\n    }\n\n    return 52;\n  },\n  //either name or number\n  month: function month(input) {\n    if (input !== undefined) {\n      var s = this.clone();\n      s.epoch = set.month(s, input);\n      return s;\n    }\n\n    return this.d.getMonth();\n  }\n};\nvar _02Date = methods$2;\nvar methods$3 = {\n  // day 0-366\n  dayOfYear: function dayOfYear(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n      s.epoch = set.dayOfYear(s, num);\n      return s;\n    } //days since newyears - jan 1st is 1, jan 2nd is 2...\n\n\n    var sum = 0;\n    var month = this.d.getMonth();\n    var tmp; //count the num days in each month\n\n    for (var _i13 = 1; _i13 <= month; _i13++) {\n      tmp = new Date();\n      tmp.setDate(1);\n      tmp.setYear(this.d.getFullYear()); //the year matters, because leap-years\n\n      tmp.setHours(1);\n      tmp.setMinutes(1);\n      tmp.setMonth(_i13);\n      tmp.setHours(-2); //the last day of the month\n\n      sum += tmp.getDate();\n    }\n\n    return sum + this.d.getDate();\n  },\n  //'january'\n  monthName: function monthName(input) {\n    if (input === undefined) {\n      return months.long()[this.month()];\n    }\n\n    var s = this.clone();\n    s = s.month(input);\n    return s;\n  },\n  //q1, q2, q3, q4\n  quarter: function quarter(num) {\n    if (num !== undefined) {\n      if (typeof num === 'string') {\n        num = num.replace(/^q/i, '');\n        num = parseInt(num, 10);\n      }\n\n      if (quarters[num]) {\n        var s = this.clone();\n        var _month = quarters[num][0];\n        s = s.month(_month);\n        s = s.date(1);\n        s = s.startOf('day');\n        return s;\n      }\n    }\n\n    var month = this.d.getMonth();\n\n    for (var _i14 = 1; _i14 < quarters.length; _i14++) {\n      if (month < quarters[_i14][0]) {\n        return _i14 - 1;\n      }\n    }\n\n    return 4;\n  },\n  //spring, summer, winter, fall\n  season: function season(input) {\n    var hem = 'north';\n\n    if (this.hemisphere() === 'South') {\n      hem = 'south';\n    }\n\n    if (input !== undefined) {\n      var s = this.clone();\n\n      for (var _i15 = 0; _i15 < seasons[hem].length; _i15++) {\n        if (input === seasons[hem][_i15][0]) {\n          s = s.month(seasons[hem][_i15][1]);\n          s = s.date(1);\n          s = s.startOf('day');\n        }\n      }\n\n      return s;\n    }\n\n    var month = this.d.getMonth();\n\n    for (var _i16 = 0; _i16 < seasons[hem].length - 1; _i16++) {\n      if (month >= seasons[hem][_i16][1] && month < seasons[hem][_i16 + 1][1]) {\n        return seasons[hem][_i16][0];\n      }\n    }\n\n    return 'winter';\n  },\n  //the year number\n  year: function year(num) {\n    if (num !== undefined) {\n      var s = this.clone();\n      s.epoch = set.year(s, num);\n      return s;\n    }\n\n    return this.d.getFullYear();\n  },\n  //bc/ad years\n  era: function era(str) {\n    if (str !== undefined) {\n      var s = this.clone();\n      str = str.toLowerCase(); //TODO: there is no year-0AD i think. may have off-by-1 error here\n\n      var year = s.d.getFullYear(); //make '1992' into 1992bc..\n\n      if (str === 'bc' && year > 0) {\n        s.epoch = set.year(s, year * -1);\n      } //make '1992bc' into '1992'\n\n\n      if (str === 'ad' && year < 0) {\n        s.epoch = set.year(s, year * -1);\n      }\n\n      return s;\n    }\n\n    if (this.d.getFullYear() < 0) {\n      return 'BC';\n    }\n\n    return 'AD';\n  }\n};\nvar _03Year = methods$3;\nvar methods$4 = Object.assign({}, _01Time, _02Date, _03Year); //aliases\n\nmethods$4.milliseconds = methods$4.millisecond;\nmethods$4.seconds = methods$4.second;\nmethods$4.minutes = methods$4.minute;\nmethods$4.hours = methods$4.hour;\nmethods$4.hour24 = methods$4.hour;\nmethods$4.h12 = methods$4.hour12;\nmethods$4.h24 = methods$4.hour24;\nmethods$4.days = methods$4.day;\n\nvar addMethods = function addMethods(Space) {\n  //hook the methods into prototype\n  Object.keys(methods$4).forEach(function (k) {\n    Space.prototype[k] = methods$4[k];\n  });\n};\n\nvar query = addMethods;\nvar order$1 = ['millisecond', 'second', 'minute', 'hour', 'date', 'month'];\nvar keep = {\n  second: order$1.slice(0, 1),\n  minute: order$1.slice(0, 2),\n  quarterhour: order$1.slice(0, 2),\n  hour: order$1.slice(0, 3),\n  date: order$1.slice(0, 4),\n  month: order$1.slice(0, 4),\n  quarter: order$1.slice(0, 4),\n  season: order$1.slice(0, 4),\n  year: order$1,\n  decade: order$1,\n  century: order$1\n};\nkeep.week = keep.hour;\nkeep.season = keep.date;\nkeep.quarter = keep.date; // Units need to be dst adjuested\n\nvar dstAwareUnits = {\n  year: true,\n  quarter: true,\n  season: true,\n  month: true,\n  week: true,\n  day: true\n};\nvar keepDate = {\n  month: true,\n  quarter: true,\n  season: true,\n  year: true\n}; //month is the only thing we 'model/compute'\n//- because ms-shifting can be off by enough\n\nvar rollMonth = function rollMonth(want, old) {\n  //increment year\n  if (want.month > 0) {\n    var years = parseInt(want.month / 12, 10);\n    want.year = old.year() + years;\n    want.month = want.month % 12;\n  } else if (want.month < 0) {\n    //decrement year\n    var _years = Math.floor(Math.abs(want.month) / 13, 10);\n\n    _years = Math.abs(_years) + 1;\n    want.year = old.year() - _years; //ignore extras\n\n    want.month = want.month % 12;\n    want.month = want.month + 12;\n\n    if (want.month === 12) {\n      want.month = 0;\n    }\n  }\n\n  return want;\n};\n\nvar addMethods$1 = function addMethods$1(SpaceTime) {\n  SpaceTime.prototype.add = function (num, unit) {\n    var s = this.clone();\n\n    if (!unit || num === 0) {\n      return s; //don't bother\n    }\n\n    var old = this.clone();\n    unit = fns.normalize(unit); //move forward by the estimated milliseconds (rough)\n\n    if (milliseconds[unit]) {\n      s.epoch += milliseconds[unit] * num;\n    } else if (unit === 'week') {\n      s.epoch += milliseconds.day * (num * 7);\n    } else if (unit === 'quarter' || unit === 'season') {\n      s.epoch += milliseconds.month * (num * 4);\n    } else if (unit === 'season') {\n      s.epoch += milliseconds.month * (num * 4);\n    } else if (unit === 'quarterhour') {\n      s.epoch += milliseconds.minute * 15 * num;\n    } //now ensure our milliseconds/etc are in-line\n\n\n    var want = {};\n\n    if (keep[unit]) {\n      keep[unit].forEach(function (u) {\n        want[u] = old[u]();\n      });\n    }\n\n    if (dstAwareUnits[unit]) {\n      var _diff = old.timezone().current.offset - s.timezone().current.offset;\n\n      s.epoch += _diff * 3600 * 1000;\n    } //ensure month/year has ticked-over\n\n\n    if (unit === 'month') {\n      want.month = old.month() + num; //month is the one unit we 'model' directly\n\n      want = rollMonth(want, old);\n    } //support coercing a week, too\n\n\n    if (unit === 'week') {\n      var sum = old.date() + num * 7;\n\n      if (sum <= 28 && sum > 1) {\n        want.date = sum;\n      }\n    } //support 25-hour day-changes on dst-changes\n    else if (unit === 'date') {\n        //specify a naive date number, if it's easy to do...\n        var _sum = old.date() + num;\n\n        if (_sum <= 28 && _sum > 1) {\n          want.date = _sum;\n        } //or if we haven't moved at all..\n        else if (num !== 0 && old.isSame(s, 'day')) {\n            want.date = old.date() + num;\n          }\n      } //ensure year has changed (leap-years)\n      else if (unit === 'year' && s.year() === old.year()) {\n          s.epoch += milliseconds.week;\n        } //these are easier\n        else if (unit === 'decade') {\n            want.year = s.year() + 10;\n          } else if (unit === 'century') {\n            want.year = s.year() + 100;\n          } //keep current date, unless the month doesn't have it.\n\n\n    if (keepDate[unit]) {\n      var max = monthLengths_1[want.month];\n      want.date = old.date();\n\n      if (want.date > max) {\n        want.date = max;\n      }\n    }\n\n    walk_1(s, want);\n    return s;\n  }; //subtract is only add *-1\n\n\n  SpaceTime.prototype.subtract = function (num, unit) {\n    var s = this.clone();\n    return s.add(num * -1, unit);\n  }; //add aliases\n\n\n  SpaceTime.prototype.minus = SpaceTime.prototype.subtract;\n  SpaceTime.prototype.plus = SpaceTime.prototype.add;\n};\n\nvar add = addMethods$1; //make a string, for easy comparison between dates\n\nvar print = {\n  millisecond: function millisecond(s) {\n    return s.epoch;\n  },\n  second: function second(s) {\n    return [s.year(), s.month(), s.date(), s.hour(), s.minute(), s.second()].join('-');\n  },\n  minute: function minute(s) {\n    return [s.year(), s.month(), s.date(), s.hour(), s.minute()].join('-');\n  },\n  hour: function hour(s) {\n    return [s.year(), s.month(), s.date(), s.hour()].join('-');\n  },\n  day: function day(s) {\n    return [s.year(), s.month(), s.date()].join('-');\n  },\n  week: function week(s) {\n    return [s.year(), s.week()].join('-');\n  },\n  month: function month(s) {\n    return [s.year(), s.month()].join('-');\n  },\n  quarter: function quarter(s) {\n    return [s.year(), s.quarter()].join('-');\n  },\n  year: function year(s) {\n    return s.year();\n  }\n};\nprint.date = print.day;\n\nvar addMethods$2 = function addMethods$2(SpaceTime) {\n  SpaceTime.prototype.isSame = function (b, unit) {\n    var a = this;\n\n    if (!unit) {\n      return null;\n    }\n\n    if (typeof b === 'string' || typeof b === 'number') {\n      b = new SpaceTime(b, this.timezone.name);\n    } //support 'seconds' aswell as 'second'\n\n\n    unit = unit.replace(/s$/, '');\n\n    if (print[unit]) {\n      return print[unit](a) === print[unit](b);\n    }\n\n    return null;\n  };\n};\n\nvar same = addMethods$2;\n\nvar addMethods$3 = function addMethods$3(SpaceTime) {\n  var methods = {\n    isAfter: function isAfter(d) {\n      d = fns.beADate(d, this);\n      var epoch = fns.getEpoch(d);\n\n      if (epoch === null) {\n        return null;\n      }\n\n      return this.epoch > epoch;\n    },\n    isBefore: function isBefore(d) {\n      d = fns.beADate(d, this);\n      var epoch = fns.getEpoch(d);\n\n      if (epoch === null) {\n        return null;\n      }\n\n      return this.epoch < epoch;\n    },\n    isEqual: function isEqual(d) {\n      d = fns.beADate(d, this);\n      var epoch = fns.getEpoch(d);\n\n      if (epoch === null) {\n        return null;\n      }\n\n      return this.epoch === epoch;\n    },\n    isBetween: function isBetween(start, end) {\n      start = fns.beADate(start, this);\n      end = fns.beADate(end, this);\n      var startEpoch = fns.getEpoch(start);\n\n      if (startEpoch === null) {\n        return null;\n      }\n\n      var endEpoch = fns.getEpoch(end);\n\n      if (endEpoch === null) {\n        return null;\n      }\n\n      return startEpoch < this.epoch && this.epoch < endEpoch;\n    }\n  }; //hook them into proto\n\n  Object.keys(methods).forEach(function (k) {\n    SpaceTime.prototype[k] = methods[k];\n  });\n};\n\nvar compare = addMethods$3;\n\nvar addMethods$4 = function addMethods$4(SpaceTime) {\n  var methods = {\n    i18n: function i18n(data) {\n      //change the day names\n      if (fns.isObject(data.days)) {\n        days.set(data.days);\n      } //change the month names\n\n\n      if (fns.isObject(data.months)) {\n        months.set(data.months);\n      }\n    }\n  }; //hook them into proto\n\n  Object.keys(methods).forEach(function (k) {\n    SpaceTime.prototype[k] = methods[k];\n  });\n};\n\nvar i18n = addMethods$4;\nvar timezones = unpack; //fake timezone-support, for fakers (es5 class)\n\nvar SpaceTime = function SpaceTime(input$1, tz) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  //the holy moment\n  this.epoch = null; //the shift for the given timezone\n\n  this.tz = find(tz, timezones); //whether to output warnings to console\n\n  this.silent = options.silent || true; //does the week start on sunday, or monday:\n\n  this._weekStart = 1; //default to monday\n\n  if (options.weekStart !== undefined) {\n    this._weekStart = options.weekStart;\n  } //add getter/setters\n\n\n  Object.defineProperty(this, 'd', {\n    //return a js date object\n    get: function get() {\n      var offset = quick(this); //every computer is somewhere- get this computer's built-in offset\n\n      var bias = new Date(this.epoch).getTimezoneOffset() || 0; //movement\n\n      var shift = bias + offset * 60; //in minutes\n\n      shift = shift * 60 * 1000; //in ms\n      //remove this computer's offset\n\n      var epoch = this.epoch + shift;\n      var d = new Date(epoch);\n      return d;\n    }\n  }); //add this data on the object, to allow adding new timezones\n\n  Object.defineProperty(this, 'timezones', {\n    get: function get() {\n      return timezones;\n    },\n    set: function set(obj) {\n      timezones = obj;\n      return obj;\n    }\n  }); //parse the various formats\n\n  if (input$1 !== undefined || input$1 === null) {\n    var tmp = input(this, input$1, tz);\n    this.epoch = tmp.epoch;\n  }\n}; //(add instance methods to prototype)\n\n\nObject.keys(methods_1).forEach(function (k) {\n  SpaceTime.prototype[k] = methods_1[k];\n}); // ¯\\_(ツ)_/¯\n\nSpaceTime.prototype.clone = function () {\n  return new SpaceTime(this.epoch, this.tz, {\n    silent: this.silent,\n    weekStart: this._weekStart\n  });\n}; //append more methods\n\n\nquery(SpaceTime);\nadd(SpaceTime);\nsame(SpaceTime);\ncompare(SpaceTime);\ni18n(SpaceTime);\nvar spacetime = SpaceTime; // const timezones = require('../data');\n\nvar whereIts = function whereIts(a, b) {\n  var start = new spacetime(null);\n  var end = new spacetime(null);\n  start = start.time(a); //if b is undefined, use as 'within one hour'\n\n  if (b) {\n    end = end.time(b);\n  } else {\n    end = start.add(59, 'minutes');\n  }\n\n  var startHour = start.hour();\n  var endHour = end.hour();\n  var tzs = Object.keys(start.timezones).filter(function (tz) {\n    if (tz.indexOf('/') === -1) {\n      return false;\n    }\n\n    var m = new spacetime(null, tz);\n    var hour = m.hour(); //do 'calendar-compare' not real-time-compare\n\n    if (hour >= startHour && hour <= endHour) {\n      //test minutes too, if applicable\n      if (hour === startHour && m.minute() < start.minute()) {\n        return false;\n      }\n\n      if (hour === endHour && m.minute() > end.minute()) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return tzs;\n};\n\nvar whereIts_1 = whereIts;\nvar _version = '5.10.0';\n\nvar main$1 = function main$1(input, tz, options) {\n  return new spacetime(input, tz, options);\n}; //some helper functions on the main method\n\n\nmain$1.now = function (tz, options) {\n  return new spacetime(new Date().getTime(), tz, options);\n};\n\nmain$1.today = function (tz, options) {\n  var s = new spacetime(new Date().getTime(), tz, options);\n  return s.startOf('day');\n};\n\nmain$1.tomorrow = function (tz, options) {\n  var s = new spacetime(new Date().getTime(), tz, options);\n  return s.add(1, 'day').startOf('day');\n};\n\nmain$1.yesterday = function (tz, options) {\n  var s = new spacetime(new Date().getTime(), tz, options);\n  return s.subtract(1, 'day').startOf('day');\n};\n\nmain$1.extend = function (obj) {\n  Object.keys(obj).forEach(function (k) {\n    spacetime.prototype[k] = obj[k];\n  });\n  return this;\n}; //find tz by time\n\n\nmain$1.whereIts = whereIts_1;\nmain$1.version = _version; //aliases:\n\nmain$1.plugin = main$1.extend;\nvar src = main$1;\nexport default src;","map":null,"metadata":{},"sourceType":"module"}